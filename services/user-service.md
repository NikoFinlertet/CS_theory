# üë§ User Service - Go + DDD + CQRS

## üìù –û–ø–∏—Å–∞–Ω–∏–µ

–ú–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏, –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É—é—â–∏–π —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø–æ–¥—Ö–æ–¥—ã:
- **Domain-Driven Design (DDD)** –¥–ª—è –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—è –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∏
- **Command Query Responsibility Segregation (CQRS)** –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π
- **Clean Architecture** –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ—Å—Ç–∏ –∫–æ–¥–∞
- **GoF Design Patterns** –¥–ª—è –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

---

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

### Clean Architecture —Å–ª–æ–∏

```mermaid
graph TB
    subgraph "Infrastructure Layer"
        API[REST API Handlers]
        DB[PostgreSQL Repository]
        Event[Redis Event Bus]
        Config[Configuration]
    end
    
    subgraph "Interface Adapters"
        Controllers[Controllers]
        Gateways[Gateways]
        Presenters[Presenters]
    end
    
    subgraph "Use Cases"
        Commands[Command Handlers]
        Queries[Query Handlers]
        Services[Application Services]
    end
    
    subgraph "Entities (Domain)"
        User[User Aggregate]
        ValueObjects[Email, UserID]
        Events[Domain Events]
        Repository[Repository Interface]
    end
    
    API --> Controllers
    Controllers --> Commands
    Controllers --> Queries
    Commands --> User
    Queries --> User
    User --> Repository
    Repository --> DB
    Commands --> Event
```

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

```
user-service/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ main.go                # üöÄ –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ domain/                # üèõÔ∏è –î–æ–º–µ–Ω–Ω—ã–π —Å–ª–æ–π
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.go           # User Aggregate Root
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.go         # Domain Events
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repository.go     # Repository Interface
‚îÇ   ‚îú‚îÄ‚îÄ application/          # üìã –°–ª–æ–π –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands.go       # Command Handlers (CQRS)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ queries.go        # Query Handlers (CQRS)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto.go            # Data Transfer Objects
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/       # üîß –ò–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–π —Å–ª–æ–π
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repository.go     # PostgreSQL Repository
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.go       # Database Connection
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.go         # Configuration
‚îÇ   ‚îî‚îÄ‚îÄ api/                  # üåê API —Å–ª–æ–π
‚îÇ       ‚îú‚îÄ‚îÄ rest_handler.go   # HTTP Handlers
‚îÇ       ‚îú‚îÄ‚îÄ middleware.go     # Middleware
‚îÇ       ‚îî‚îÄ‚îÄ routes.go         # Route Definitions
```

---

## üéØ Domain-Driven Design

### –ê–≥—Ä–µ–≥–∞—Ç User

```go
// User - –∫–æ—Ä–µ–Ω—å –∞–≥—Ä–µ–≥–∞—Ç–∞ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
type User struct {
    ID        UserID    `json:"id"`
    Email     Email     `json:"email"`
    Name      string    `json:"name"`
    Status    UserStatus `json:"status"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
    Version   int       `json:"version"` // –¥–ª—è Optimistic Locking
}

// –ë–∏–∑–Ω–µ—Å-–º–µ—Ç–æ–¥—ã –∞–≥—Ä–µ–≥–∞—Ç–∞
func (u *User) Block() error {
    if u.Status == UserStatusBlocked {
        return ErrUserAlreadyBlocked
    }
    u.Status = UserStatusBlocked
    u.UpdatedAt = time.Now()
    return nil
}

func (u *User) Unblock() error {
    if u.Status != UserStatusBlocked {
        return ErrUserNotBlocked
    }
    u.Status = UserStatusActive
    u.UpdatedAt = time.Now()
    return nil
}

func (u *User) ChangeEmail(newEmail Email) error {
    if u.Email.Equals(newEmail) {
        return ErrEmailUnchanged
    }
    u.Email = newEmail
    u.UpdatedAt = time.Now()
    return nil
}
```

### Value Objects

```go
// Email - Value Object –¥–ª—è email –∞–¥—Ä–µ—Å–∞
type Email struct {
    value string
}

func NewEmail(email string) (Email, error) {
    if !isValidEmail(email) {
        return Email{}, ErrInvalidEmail
    }
    return Email{value: strings.ToLower(email)}, nil
}

func (e Email) String() string {
    return e.value
}

func (e Email) Equals(other Email) bool {
    return e.value == other.value
}

// UserID - Value Object –¥–ª—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
type UserID struct {
    value uuid.UUID
}

func NewUserID() UserID {
    return UserID{value: uuid.New()}
}

func ParseUserID(s string) (UserID, error) {
    id, err := uuid.Parse(s)
    if err != nil {
        return UserID{}, ErrInvalidUserID
    }
    return UserID{value: id}, nil
}
```

### Domain Events

```go
// UserCreatedEvent - —Å–æ–±—ã—Ç–∏–µ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
type UserCreatedEvent struct {
    UserID    UserID    `json:"user_id"`
    Email     Email     `json:"email"`
    Name      string    `json:"name"`
    CreatedAt time.Time `json:"created_at"`
}

func (e UserCreatedEvent) EventType() string {
    return "user.created"
}

// UserBlockedEvent - —Å–æ–±—ã—Ç–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
type UserBlockedEvent struct {
    UserID    UserID    `json:"user_id"`
    Reason    string    `json:"reason"`
    BlockedAt time.Time `json:"blocked_at"`
}

func (e UserBlockedEvent) EventType() string {
    return "user.blocked"
}
```

---

## ‚ö° CQRS Implementation

### Command Side

```go
// CreateUserCommand - –∫–æ–º–∞–Ω–¥–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
type CreateUserCommand struct {
    Email    string `json:"email" binding:"required,email"`
    Name     string `json:"name" binding:"required,min=2,max=100"`
    Password string `json:"password" binding:"required,min=8"`
}

// CreateUserCommandHandler - –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã —Å–æ–∑–¥–∞–Ω–∏—è
type CreateUserCommandHandler struct {
    userRepo   domain.UserRepository
    eventBus   EventBus
    logger     *zap.Logger
}

func (h *CreateUserCommandHandler) Handle(ctx context.Context, cmd CreateUserCommand) (*UserResponse, error) {
    // 1. –í–∞–ª–∏–¥–∞—Ü–∏—è –∏ —Å–æ–∑–¥–∞–Ω–∏–µ Value Objects
    email, err := domain.NewEmail(cmd.Email)
    if err != nil {
        return nil, err
    }
    
    // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∏–∑–Ω–µ—Å-–ø—Ä–∞–≤–∏–ª
    existing, err := h.userRepo.GetByEmail(ctx, email)
    if err != nil && !errors.Is(err, domain.ErrUserNotFound) {
        return nil, err
    }
    if existing != nil {
        return nil, domain.ErrUserAlreadyExists
    }
    
    // 3. –°–æ–∑–¥–∞–Ω–∏–µ –∞–≥—Ä–µ–≥–∞—Ç–∞
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(cmd.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, err
    }
    
    user := domain.NewUser(email, cmd.Name, string(hashedPassword))
    
    // 4. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
    err = h.userRepo.Save(ctx, user)
    if err != nil {
        return nil, err
    }
    
    // 5. –ü—É–±–ª–∏–∫–∞—Ü–∏—è –¥–æ–º–µ–Ω–Ω–æ–≥–æ —Å–æ–±—ã—Ç–∏—è
    event := domain.UserCreatedEvent{
        UserID:    user.ID,
        Email:     user.Email,
        Name:      user.Name,
        CreatedAt: user.CreatedAt,
    }
    
    err = h.eventBus.Publish(ctx, event)
    if err != nil {
        h.logger.Error("failed to publish event", zap.Error(err))
    }
    
    return convertToUserResponse(user), nil
}
```

### Query Side

```go
// GetUserQuery - –∑–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ ID
type GetUserQuery struct {
    UserID string `uri:"id" binding:"required,uuid"`
}

// GetUserQueryHandler - –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–ø—Ä–æ—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
type GetUserQueryHandler struct {
    userRepo domain.UserRepository
    cache    Cache
    logger   *zap.Logger
}

func (h *GetUserQueryHandler) Handle(ctx context.Context, query GetUserQuery) (*UserResponse, error) {
    userID, err := domain.ParseUserID(query.UserID)
    if err != nil {
        return nil, err
    }
    
    // –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –∫–µ—à–∞
    cacheKey := fmt.Sprintf("user:%s", userID.String())
    if cached, err := h.cache.Get(ctx, cacheKey); err == nil {
        var user UserResponse
        if err := json.Unmarshal(cached, &user); err == nil {
            return &user, nil
        }
    }
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–∑ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
    user, err := h.userRepo.GetByID(ctx, userID)
    if err != nil {
        return nil, err
    }
    
    response := convertToUserResponse(user)
    
    // –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    if data, err := json.Marshal(response); err == nil {
        h.cache.Set(ctx, cacheKey, data, time.Hour)
    }
    
    return response, nil
}
```

---

## üîß Infrastructure Layer

### Repository Implementation

```go
// PostgresUserRepository - —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è –¥–ª—è PostgreSQL
type PostgresUserRepository struct {
    db *gorm.DB
}

func NewPostgresUserRepository(db *gorm.DB) *PostgresUserRepository {
    return &PostgresUserRepository{db: db}
}

func (r *PostgresUserRepository) Save(ctx context.Context, user *domain.User) error {
    userModel := convertToUserModel(user)
    
    // Optimistic locking
    result := r.db.WithContext(ctx).
        Where("id = ? AND version = ?", user.ID.String(), user.Version-1).
        Save(userModel)
    
    if result.Error != nil {
        return result.Error
    }
    
    if result.RowsAffected == 0 {
        return domain.ErrConcurrentUpdate
    }
    
    return nil
}

func (r *PostgresUserRepository) GetByID(ctx context.Context, id domain.UserID) (*domain.User, error) {
    var userModel UserModel
    
    err := r.db.WithContext(ctx).
        Where("id = ?", id.String()).
        First(&userModel).Error
    
    if errors.Is(err, gorm.ErrRecordNotFound) {
        return nil, domain.ErrUserNotFound
    }
    
    if err != nil {
        return nil, err
    }
    
    return convertToDomainUser(&userModel)
}
```

### Event Bus Implementation

```go
// RedisEventBus - —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è Event Bus —Å Redis Pub/Sub
type RedisEventBus struct {
    client *redis.Client
    logger *zap.Logger
}

func NewRedisEventBus(redisURL string) *RedisEventBus {
    opts, err := redis.ParseURL(redisURL)
    if err != nil {
        log.Fatal("Failed to parse Redis URL:", err)
    }
    
    client := redis.NewClient(opts)
    
    return &RedisEventBus{
        client: client,
        logger: zap.NewExample(),
    }
}

func (e *RedisEventBus) Publish(ctx context.Context, event domain.DomainEvent) error {
    eventData := EventEnvelope{
        EventType: event.EventType(),
        EventID:   uuid.New().String(),
        Timestamp: time.Now(),
        Data:      event,
    }
    
    jsonData, err := json.Marshal(eventData)
    if err != nil {
        return err
    }
    
    return e.client.Publish(ctx, event.EventType(), jsonData).Err()
}
```

---

## üåê API Layer

### REST Handlers

```go
// UserHandler - HTTP –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è User API
type UserHandler struct {
    commandHandler *application.CommandHandler
    queryHandler   *application.QueryHandler
}

func NewUserHandler(ch *application.CommandHandler, qh *application.QueryHandler) *UserHandler {
    return &UserHandler{
        commandHandler: ch,
        queryHandler:   qh,
    }
}

// CreateUser - POST /users
func (h *UserHandler) CreateUser(c *gin.Context) {
    var cmd application.CreateUserCommand
    
    if err := c.ShouldBindJSON(&cmd); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse{
            Error: "Invalid request body",
            Details: err.Error(),
        })
        return
    }
    
    user, err := h.commandHandler.CreateUser(c.Request.Context(), cmd)
    if err != nil {
        handleError(c, err)
        return
    }
    
    c.JSON(http.StatusCreated, user)
}

// GetUser - GET /users/:id
func (h *UserHandler) GetUser(c *gin.Context) {
    var query application.GetUserQuery
    
    if err := c.ShouldBindUri(&query); err != nil {
        c.JSON(http.StatusBadRequest, ErrorResponse{
            Error: "Invalid user ID",
            Details: err.Error(),
        })
        return
    }
    
    user, err := h.queryHandler.GetUser(c.Request.Context(), query)
    if err != nil {
        handleError(c, err)
        return
    }
    
    c.JSON(http.StatusOK, user)
}
```

### Middleware

```go
// AuthMiddleware - middleware –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ JWT
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        tokenString := extractTokenFromHeader(c.GetHeader("Authorization"))
        if tokenString == "" {
            c.JSON(http.StatusUnauthorized, ErrorResponse{
                Error: "Missing authorization token",
            })
            c.Abort()
            return
        }
        
        claims, err := validateJWTToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, ErrorResponse{
                Error: "Invalid token",
                Details: err.Error(),
            })
            c.Abort()
            return
        }
        
        c.Set("user_id", claims.UserID)
        c.Set("user_roles", claims.Roles)
        c.Next()
    }
}

// CORSMiddleware - middleware –¥–ª—è CORS
func CORSMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
        c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
        c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        c.Writer.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    }
}
```

---

## üîß –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ –∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã

### Core Technologies
- **Go 1.21+** - –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π Go —Å generics
- **Gin** - HTTP web framework —Å –≤—ã—Å–æ–∫–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é
- **GORM** - ORM –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å PostgreSQL
- **Redis** - Event Bus –∏ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ
- **JWT** - Stateless –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è

### Design Patterns
- **Domain-Driven Design** - –ú–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∏
- **CQRS** - –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥ –∏ –∑–∞–ø—Ä–æ—Å–æ–≤
- **Repository Pattern** - –ê–±—Å—Ç—Ä–∞–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–∞–Ω–Ω—ã–º
- **Factory Pattern** - –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
- **Observer Pattern** - –î–æ–º–µ–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è

### Tools & Libraries
- **Zap** - Structured logging
- **Testify** - Unit testing framework
- **Swagger** - API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
- **Docker** - –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä–∏–∑–∞—Ü–∏—è
- **Prometheus** - –ú–µ—Ç—Ä–∏–∫–∏ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥

---

## üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### Unit Tests

```go
// TestCreateUser - —Ç–µ—Å—Ç —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
func TestCreateUser(t *testing.T) {
    // Arrange
    mockRepo := &MockUserRepository{}
    mockEventBus := &MockEventBus{}
    handler := NewCreateUserCommandHandler(mockRepo, mockEventBus)
    
    cmd := CreateUserCommand{
        Email:    "test@example.com",
        Name:     "Test User",
        Password: "password123",
    }
    
    mockRepo.On("GetByEmail", mock.Anything, mock.Anything).Return(nil, domain.ErrUserNotFound)
    mockRepo.On("Save", mock.Anything, mock.Anything).Return(nil)
    mockEventBus.On("Publish", mock.Anything, mock.Anything).Return(nil)
    
    // Act
    user, err := handler.Handle(context.Background(), cmd)
    
    // Assert
    assert.NoError(t, err)
    assert.NotNil(t, user)
    assert.Equal(t, cmd.Email, user.Email)
    assert.Equal(t, cmd.Name, user.Name)
    
    mockRepo.AssertExpectations(t)
    mockEventBus.AssertExpectations(t)
}
```

### Integration Tests

```go
// TestUserRepository_Integration - –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ç–µ—Å—Ç —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
func TestUserRepository_Integration(t *testing.T) {
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–π –ë–î
    db := setupTestDatabase(t)
    defer cleanupTestDatabase(t, db)
    
    repo := NewPostgresUserRepository(db)
    
    // –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    email, _ := domain.NewEmail("test@example.com")
    user := domain.NewUser(email, "Test User", "hashedpassword")
    
    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
    err := repo.Save(context.Background(), user)
    assert.NoError(t, err)
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ
    retrieved, err := repo.GetByID(context.Background(), user.ID)
    assert.NoError(t, err)
    assert.Equal(t, user.Email, retrieved.Email)
    assert.Equal(t, user.Name, retrieved.Name)
}
```

---

## üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –Ω–∞–±–ª—é–¥–∞–µ–º–æ—Å—Ç—å

### –ú–µ—Ç—Ä–∏–∫–∏ (Prometheus)

```go
var (
    userCreations = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "user_creations_total",
            Help: "Total number of user creations",
        },
        []string{"status"},
    )
    
    userQueries = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "user_query_duration_seconds",
            Help: "Duration of user queries",
        },
        []string{"operation"},
    )
)

// InstrumentationMiddleware - middleware –¥–ª—è –º–µ—Ç—Ä–∏–∫
func InstrumentationMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        c.Next()
        
        duration := time.Since(start)
        
        userQueries.WithLabelValues(c.Request.URL.Path).Observe(duration.Seconds())
        
        if c.Writer.Status() >= 200 && c.Writer.Status() < 300 {
            userCreations.WithLabelValues("success").Inc()
        } else {
            userCreations.WithLabelValues("error").Inc()
        }
    }
}
```

### Structured Logging

```go
// Logger configuration
func NewLogger() *zap.Logger {
    config := zap.NewProductionConfig()
    config.OutputPaths = []string{"stdout"}
    config.EncoderConfig.TimeKey = "timestamp"
    config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    
    logger, _ := config.Build()
    return logger
}

// Usage in handlers
func (h *UserHandler) CreateUser(c *gin.Context) {
    logger := h.logger.With(
        zap.String("request_id", c.GetString("request_id")),
        zap.String("operation", "create_user"),
    )
    
    logger.Info("Processing create user request")
    
    // ... business logic ...
    
    logger.Info("User created successfully",
        zap.String("user_id", user.ID.String()),
        zap.String("email", user.Email.String()),
    )
}
```

---

## üîó –°–≤—è–∑–∞–Ω–Ω—ã–µ —Ç–µ–º—ã

- [[../fundamentals/ddd-patterns|DDD Patterns]]
- [[../fundamentals/cqrs-pattern|CQRS Pattern]]
- [[../fundamentals/clean-architecture|Clean Architecture]]
- [[../architecture/microservices-architecture|Microservices Architecture]]
- [[../technical-skills/testing|Testing Strategies]]
- [[order-service|Order Service]] - –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤—É—é—â–∏–π —Å–µ—Ä–≤–∏—Å
- [[api-gateway|API Gateway]] - —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞

---

## üéØ –ö–ª—é—á–µ–≤—ã–µ –≤—ã–≤–æ–¥—ã

### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ DDD + CQRS
- **–ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ** –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∏ –∏ –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—ã
- **–í—ã—Å–æ–∫–∞—è —Ç–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å** –±–ª–∞–≥–æ–¥–∞—Ä—è —á–∏—Å—Ç–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ
- **–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å** —á—Ç–µ–Ω–∏—è –∏ –∑–∞–ø–∏—Å–∏ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ
- **–°–æ–±—ã—Ç–∏–π–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è** –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

### Best Practices
- **Value Objects** –¥–ª—è —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
- **–ê–≥—Ä–µ–≥–∞—Ç—ã** –¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö
- **Domain Events** –¥–ª—è —Å–ª–∞–±–æ–π —Å–≤—è–∑–∞–Ω–Ω–æ—Å—Ç–∏
- **Repository Pattern** –¥–ª—è –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö
- **Optimistic Locking** –¥–ª—è –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ—Å—Ç–∏

### –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
- **–ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ** –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ Redis
- **Connection Pooling** –¥–ª—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
- **–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ** –¥–æ–º–µ–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è
- **Graceful Shutdown** –¥–ª—è zero-downtime deployments 