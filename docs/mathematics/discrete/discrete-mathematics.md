# –î–∏—Å–∫—Ä–µ—Ç–Ω–∞—è –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞: –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –∫—É—Ä—Å

## üéØ –¶–µ–ª—å –∫—É—Ä—Å–∞

–£–≥–ª—É–±–ª–µ–Ω–Ω–æ–µ –∏–∑—É—á–µ–Ω–∏–µ –¥–∏—Å–∫—Ä–µ—Ç–Ω–æ–π –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏ —Å –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–º–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è–º–∏ –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–∞—Ö, –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –∏ —Ç–µ–æ—Ä–∏–∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π.

## üìö –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

1. [–¢–µ–æ—Ä–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤ –∏ –ª–æ–≥–∏–∫–∞](#—Ç–µ–æ—Ä–∏—è-–º–Ω–æ–∂–µ—Å—Ç–≤-–∏-–ª–æ–≥–∏–∫–∞)
2. [–¢–µ–æ—Ä–∏—è –≥—Ä–∞—Ñ–æ–≤](#—Ç–µ–æ—Ä–∏—è-–≥—Ä–∞—Ñ–æ–≤)
3. [–ö–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∏–∫–∞](#–∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∏–∫–∞)
4. [–¢–µ–æ—Ä–∏—è —á–∏—Å–µ–ª](#—Ç–µ–æ—Ä–∏—è-—á–∏—Å–µ–ª)
5. [–ê–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã](#–∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–µ-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã)
6. [–ê–≤—Ç–æ–º–∞—Ç—ã –∏ —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–µ —è–∑—ã–∫–∏](#–∞–≤—Ç–æ–º–∞—Ç—ã-–∏-—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–µ-—è–∑—ã–∫–∏)

---

## –¢–µ–æ—Ä–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤ –∏ –ª–æ–≥–∏–∫–∞

### –û—Å–Ω–æ–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞–¥ –º–Ω–æ–∂–µ—Å—Ç–≤–∞–º–∏

**–û—Å–Ω–æ–≤–Ω—ã–µ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏**:
- **–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ**: $A \cup B = \{x : x \in A \lor x \in B\}$
- **–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ**: $A \cap B = \{x : x \in A \land x \in B\}$
- **–†–∞–∑–Ω–æ—Å—Ç—å**: $A \setminus B = \{x : x \in A \land x \notin B\}$
- **–°–∏–º–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è —Ä–∞–∑–Ω–æ—Å—Ç—å**: $A \triangle B = (A \setminus B) \cup (B \setminus A)$
- **–î–æ–ø–æ–ª–Ω–µ–Ω–∏–µ**: $\bar{A} = U \setminus A$ (–≥–¥–µ $U$ ‚Äî —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ)

**–ó–∞–∫–æ–Ω—ã –¥–µ –ú–æ—Ä–≥–∞–Ω–∞**:
$$\overline{A \cup B} = \bar{A} \cap \bar{B}$$
$$\overline{A \cap B} = \bar{A} \cup \bar{B}$$

**–î–µ–∫–∞—Ä—Ç–æ–≤–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ**: $A \times B = \{(a, b) : a \in A, b \in B\}$

**–ú–æ—â–Ω–æ—Å—Ç—å –º–Ω–æ–∂–µ—Å—Ç–≤–∞**: $|A \times B| = |A| \cdot |B|$

**–ë—É–ª–µ–∞–Ω (–º–Ω–æ–∂–µ—Å—Ç–≤–æ –≤—Å–µ—Ö –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤)**: $\mathcal{P}(A) = \{X : X \subseteq A\}$

–ï—Å–ª–∏ $|A| = n$, —Ç–æ $|\mathcal{P}(A)| = 2^n$

### –û—Ç–Ω–æ—à–µ–Ω–∏—è –∏ —Ñ—É–Ω–∫—Ü–∏–∏

**–ë–∏–Ω–∞—Ä–Ω–æ–µ –æ—Ç–Ω–æ—à–µ–Ω–∏–µ**: $R \subseteq A \times B$

**–°–≤–æ–π—Å—Ç–≤–∞ –æ—Ç–Ω–æ—à–µ–Ω–∏–π –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ $A$**:
- **–†–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω–æ—Å—Ç—å**: $\forall a \in A: (a, a) \in R$
- **–°–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ—Å—Ç—å**: $\forall a, b \in A: (a, b) \in R \Rightarrow (b, a) \in R$
- **–¢—Ä–∞–Ω–∑–∏—Ç–∏–≤–Ω–æ—Å—Ç—å**: $\forall a, b, c \in A: (a, b) \in R \land (b, c) \in R \Rightarrow (a, c) \in R$

**–û—Ç–Ω–æ—à–µ–Ω–∏–µ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç–∏**: —Ä–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω–æ–µ, —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–µ –∏ —Ç—Ä–∞–Ω–∑–∏—Ç–∏–≤–Ω–æ–µ –æ—Ç–Ω–æ—à–µ–Ω–∏–µ

**–ß–∞—Å—Ç–∏—á–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫**: —Ä–µ—Ñ–ª–µ–∫—Å–∏–≤–Ω–æ–µ, –∞–Ω—Ç–∏—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–µ –∏ —Ç—Ä–∞–Ω–∑–∏—Ç–∏–≤–Ω–æ–µ –æ—Ç–Ω–æ—à–µ–Ω–∏–µ

### –û–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞–¥ –º–Ω–æ–∂–µ—Å—Ç–≤–∞–º–∏

```python
class Set:
    """–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å –æ—Å–Ω–æ–≤–Ω—ã–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏"""
    
    def __init__(self, elements=None):
        self.elements = set(elements) if elements else set()
    
    def union(self, other):
        """–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤ A ‚à™ B"""
        return Set(self.elements | other.elements)
    
    def intersection(self, other):
        """–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤ A ‚à© B"""
        return Set(self.elements & other.elements)
    
    def difference(self, other):
        """–†–∞–∑–Ω–æ—Å—Ç—å –º–Ω–æ–∂–µ—Å—Ç–≤ A \ B"""
        return Set(self.elements - other.elements)
    
    def symmetric_difference(self, other):
        """–°–∏–º–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è —Ä–∞–∑–Ω–æ—Å—Ç—å A ‚äï B"""
        return Set(self.elements ^ other.elements)
    
    def cartesian_product(self, other):
        """–î–µ–∫–∞—Ä—Ç–æ–≤–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ A √ó B"""
        return Set([(a, b) for a in self.elements for b in other.elements])
    
    def power_set(self):
        """–ë—É–ª–µ–∞–Ω –º–Ω–æ–∂–µ—Å—Ç–≤–∞ (–º–Ω–æ–∂–µ—Å—Ç–≤–æ –≤—Å–µ—Ö –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤)"""
        from itertools import combinations
        
        subsets = []
        for r in range(len(self.elements) + 1):
            for subset in combinations(self.elements, r):
                subsets.append(Set(subset))
        
        return subsets
    
    def is_subset(self, other):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∫–ª—é—á–µ–Ω–∏—è A ‚äÜ B"""
        return self.elements <= other.elements
    
    def __repr__(self):
        return f"Set({sorted(list(self.elements))})"

# –ü—Ä–∏–º–µ—Ä: –∞–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö —Å –ø–æ–º–æ—â—å—é –º–Ω–æ–∂–µ—Å—Ç–≤
def analyze_user_behavior():
    """–ê–Ω–∞–ª–∏–∑ –ø–æ–≤–µ–¥–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —á–µ—Ä–µ–∑ –º–Ω–æ–∂–µ—Å—Ç–≤–∞"""
    
    users_page_a = Set([1, 2, 3, 4, 5, 6])
    users_page_b = Set([4, 5, 6, 7, 8, 9])
    users_purchased = Set([2, 4, 6, 8, 10])
    
    # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏, –ø–æ—Å–µ—Ç–∏–≤—à–∏–µ –æ–±–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    both_pages = users_page_a.intersection(users_page_b)
    print(f"–ü–æ—Å–µ—Ç–∏–ª–∏ –æ–±–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {both_pages}")
    
    # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏, –ø–æ—Å–µ—Ç–∏–≤—à–∏–µ —Ç–æ–ª—å–∫–æ –æ–¥–Ω—É —Å—Ç—Ä–∞–Ω–∏—Ü—É
    only_a = users_page_a.difference(users_page_b)
    only_b = users_page_b.difference(users_page_a)
    print(f"–¢–æ–ª—å–∫–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ A: {only_a}")
    print(f"–¢–æ–ª—å–∫–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ B: {only_b}")
    
    # –ö–æ–Ω–≤–µ—Ä—Å–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    conversion_a = users_page_a.intersection(users_purchased)
    conversion_b = users_page_b.intersection(users_purchased)
    
    print(f"–ö–æ–Ω–≤–µ—Ä—Å–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã A: {len(conversion_a.elements)}/{len(users_page_a.elements)}")
    print(f"–ö–æ–Ω–≤–µ—Ä—Å–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã B: {len(conversion_b.elements)}/{len(users_page_b.elements)}")

analyze_user_behavior()
```

### –õ–æ–≥–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏

```python
class PropositionalLogic:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ª–æ–≥–∏–∫–æ–π –≤—ã—Å–∫–∞–∑—ã–≤–∞–Ω–∏–π"""
    
    def __init__(self):
        self.truth_table = {}
    
    def evaluate(self, expression, variables):
        """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ –∏—Å—Ç–∏–Ω–Ω–æ—Å—Ç–∏ –ª–æ–≥–∏—á–µ—Å–∫–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è"""
        # –ó–∞–º–µ–Ω—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è
        for var, value in variables.items():
            expression = expression.replace(var, str(value))
        
        # –ó–∞–º–µ–Ω—è–µ–º –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã
        expression = expression.replace('AND', ' and ')
        expression = expression.replace('OR', ' or ')
        expression = expression.replace('NOT', ' not ')
        expression = expression.replace('XOR', ' != ')
        expression = expression.replace('IMPLIES', ' <= ')  # A -> B = not A or B
        
        return eval(expression)
    
    def generate_truth_table(self, expression, variables):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü—ã –∏—Å—Ç–∏–Ω–Ω–æ—Å—Ç–∏"""
        from itertools import product
        
        table = []
        for values in product([True, False], repeat=len(variables)):
            var_assignment = dict(zip(variables, values))
            result = self.evaluate(expression, var_assignment)
            table.append((*values, result))
        
        return table
    
    def is_tautology(self, expression, variables):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ç–∞–≤—Ç–æ–ª–æ–≥–∏—é"""
        table = self.generate_truth_table(expression, variables)
        return all(row[-1] for row in table)
    
    def is_contradiction(self, expression, variables):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–µ"""
        table = self.generate_truth_table(expression, variables)
        return not any(row[-1] for row in table)
    
    def logical_equivalence(self, expr1, expr2, variables):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–æ–≥–∏—á–µ—Å–∫–æ–π —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç–∏"""
        table1 = self.generate_truth_table(expr1, variables)
        table2 = self.generate_truth_table(expr2, variables)
        
        return all(row1[-1] == row2[-1] for row1, row2 in zip(table1, table2))

# –ü—Ä–∏–º–µ—Ä: –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –∑–∞–∫–æ–Ω–æ–≤
logic = PropositionalLogic()

# –ó–∞–∫–æ–Ω –¥–µ –ú–æ—Ä–≥–∞–Ω–∞: NOT(A AND B) ‚â° (NOT A) OR (NOT B)
expr1 = "NOT(A AND B)"
expr2 = "(NOT A) OR (NOT B)"
variables = ['A', 'B']

equivalent = logic.logical_equivalence(expr1, expr2, variables)
print(f"–ó–∞–∫–æ–Ω –¥–µ –ú–æ—Ä–≥–∞–Ω–∞: {equivalent}")

# –¢–∞–±–ª–∏—Ü–∞ –∏—Å—Ç–∏–Ω–Ω–æ—Å—Ç–∏ –¥–ª—è –∏–º–ø–ª–∏–∫–∞—Ü–∏–∏
impl_table = logic.generate_truth_table("A IMPLIES B", ['A', 'B'])
print("–¢–∞–±–ª–∏—Ü–∞ –∏—Å—Ç–∏–Ω–Ω–æ—Å—Ç–∏ –¥–ª—è A ‚Üí B:")
for row in impl_table:
    print(f"A={row[0]}, B={row[1]} ‚Üí {row[2]}")
```

---

## –¢–µ–æ—Ä–∏—è –≥—Ä–∞—Ñ–æ–≤

### –û—Å–Ω–æ–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã

```python
import heapq
from collections import defaultdict, deque

class Graph:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≥—Ä–∞—Ñ–∞–º–∏"""
    
    def __init__(self, directed=False):
        self.graph = defaultdict(list)
        self.directed = directed
        self.weights = {}
    
    def add_edge(self, u, v, weight=1):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–±—Ä–∞"""
        self.graph[u].append(v)
        self.weights[(u, v)] = weight
        
        if not self.directed:
            self.graph[v].append(u)
            self.weights[(v, u)] = weight
    
    def bfs(self, start):
        """–ü–æ–∏—Å–∫ –≤ —à–∏—Ä–∏–Ω—É"""
        visited = set()
        queue = deque([start])
        result = []
        
        while queue:
            vertex = queue.popleft()
            if vertex not in visited:
                visited.add(vertex)
                result.append(vertex)
                
                for neighbor in self.graph[vertex]:
                    if neighbor not in visited:
                        queue.append(neighbor)
        
        return result
    
    def dfs(self, start, visited=None):
        """–ü–æ–∏—Å–∫ –≤ –≥–ª—É–±–∏–Ω—É"""
        if visited is None:
            visited = set()
        
        visited.add(start)
        result = [start]
        
        for neighbor in self.graph[start]:
            if neighbor not in visited:
                result.extend(self.dfs(neighbor, visited))
        
        return result
    
    def dijkstra(self, start):
        """–ê–ª–≥–æ—Ä–∏—Ç–º –î–µ–π–∫—Å—Ç—Ä—ã –¥–ª—è –∫—Ä–∞—Ç—á–∞–π—à–∏—Ö –ø—É—Ç–µ–π"""
        distances = defaultdict(lambda: float('inf'))
        distances[start] = 0
        pq = [(0, start)]
        visited = set()
        
        while pq:
            current_distance, current = heapq.heappop(pq)
            
            if current in visited:
                continue
                
            visited.add(current)
            
            for neighbor in self.graph[current]:
                distance = current_distance + self.weights.get((current, neighbor), 1)
                
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
        
        return dict(distances)
    
    def topological_sort(self):
        """–¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞"""
        in_degree = defaultdict(int)
        
        # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥—è—â–∏–µ —Å—Ç–µ–ø–µ–Ω–∏
        for vertex in self.graph:
            for neighbor in self.graph[vertex]:
                in_degree[neighbor] += 1
        
        # –ù–∞—Ö–æ–¥–∏–º –≤–µ—Ä—à–∏–Ω—ã —Å –Ω—É–ª–µ–≤–æ–π –≤—Ö–æ–¥—è—â–µ–π —Å—Ç–µ–ø–µ–Ω—å—é
        queue = deque([v for v in self.graph if in_degree[v] == 0])
        result = []
        
        while queue:
            vertex = queue.popleft()
            result.append(vertex)
            
            for neighbor in self.graph[vertex]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return result if len(result) == len(self.graph) else None
    
    def has_cycle(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —Ü–∏–∫–ª–∞"""
        color = {}  # 0: –±–µ–ª—ã–π, 1: —Å–µ—Ä—ã–π, 2: —á–µ—Ä–Ω—ã–π
        
        def dfs_cycle(vertex):
            color[vertex] = 1  # –°–µ—Ä—ã–π
            
            for neighbor in self.graph[vertex]:
                if neighbor not in color:
                    if dfs_cycle(neighbor):
                        return True
                elif color[neighbor] == 1:  # –û–±—Ä–∞—Ç–Ω–æ–µ —Ä–µ–±—Ä–æ
                    return True
            
            color[vertex] = 2  # –ß–µ—Ä–Ω—ã–π
            return False
        
        for vertex in self.graph:
            if vertex not in color:
                if dfs_cycle(vertex):
                    return True
        
        return False
    
    def strongly_connected_components(self):
        """–ü–æ–∏—Å–∫ —Å–∏–ª—å–Ω–æ —Å–≤—è–∑–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç (–∞–ª–≥–æ—Ä–∏—Ç–º –ö–æ—Å–∞—Ä–∞–π—é)"""
        # –ü–µ—Ä–≤—ã–π DFS –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        visited = set()
        finish_order = []
        
        def dfs1(v):
            visited.add(v)
            for neighbor in self.graph[v]:
                if neighbor not in visited:
                    dfs1(neighbor)
            finish_order.append(v)
        
        for vertex in self.graph:
            if vertex not in visited:
                dfs1(vertex)
        
        # –°–æ–∑–¥–∞–µ–º —Ç—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞—Ñ
        transposed = Graph(directed=True)
        for vertex in self.graph:
            for neighbor in self.graph[vertex]:
                transposed.add_edge(neighbor, vertex)
        
        # –í—Ç–æ—Ä–æ–π DFS –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ –≤—Ä–µ–º–µ–Ω –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        visited = set()
        components = []
        
        def dfs2(v, component):
            visited.add(v)
            component.append(v)
            for neighbor in transposed.graph[v]:
                if neighbor not in visited:
                    dfs2(neighbor, component)
        
        for vertex in reversed(finish_order):
            if vertex not in visited:
                component = []
                dfs2(vertex, component)
                components.append(component)
        
        return components

# –ü—Ä–∏–º–µ—Ä: –∞–Ω–∞–ª–∏–∑ —Å–æ—Ü–∏–∞–ª—å–Ω–æ–π —Å–µ—Ç–∏
def social_network_analysis():
    """–ê–Ω–∞–ª–∏–∑ —Å–æ—Ü–∏–∞–ª—å–Ω–æ–π —Å–µ—Ç–∏"""
    
    # –°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ –¥—Ä—É–∂–±—ã
    friends = Graph(directed=False)
    
    # –î–æ–±–∞–≤–ª—è–µ–º —Å–≤—è–∑–∏
    friendships = [
        ("Alice", "Bob"), ("Alice", "Charlie"), ("Bob", "David"),
        ("Charlie", "David"), ("David", "Eve"), ("Eve", "Frank"),
        ("Frank", "Alice"), ("Bob", "Eve")
    ]
    
    for friend1, friend2 in friendships:
        friends.add_edge(friend1, friend2)
    
    # –ê–Ω–∞–ª–∏–∑ —Å–≤—è–∑–Ω–æ—Å—Ç–∏
    print("–°–≤—è–∑–∏ Alice:", friends.bfs("Alice"))
    
    # –ü–æ–∏—Å–∫ –≤–ª–∏—è—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–≤—ã—Å–æ–∫–∞—è —Å—Ç–µ–ø–µ–Ω—å)
    degrees = {}
    for user in friends.graph:
        degrees[user] = len(friends.graph[user])
    
    most_connected = max(degrees, key=degrees.get)
    print(f"–°–∞–º—ã–π —Å–≤—è–∑–∞–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {most_connected} ({degrees[most_connected]} —Å–≤—è–∑–µ–π)")
    
    # –ü–æ–∏—Å–∫ –∫—Ä–∞—Ç—á–∞–π—à–µ–≥–æ –ø—É—Ç–∏ –º–µ–∂–¥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
    def shortest_path(graph, start, end):
        if start == end:
            return [start]
        
        visited = set()
        queue = deque([(start, [start])])
        
        while queue:
            vertex, path = queue.popleft()
            
            if vertex not in visited:
                visited.add(vertex)
                
                for neighbor in graph.graph[vertex]:
                    new_path = path + [neighbor]
                    if neighbor == end:
                        return new_path
                    queue.append((neighbor, new_path))
        
        return None
    
    path = shortest_path(friends, "Alice", "Frank")
    print(f"–ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å –æ—Ç Alice –∫ Frank: {' -> '.join(path)}")

social_network_analysis()
```

---

## –ö–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∏–∫–∞

### –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–æ—Ä–º—É–ª—ã –∏ –∞–ª–≥–æ—Ä–∏—Ç–º—ã

```python
import math
from itertools import combinations, permutations, product

class Combinatorics:
    """–ö–ª–∞—Å—Å –¥–ª—è –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π"""
    
    @staticmethod
    def factorial(n):
        """–§–∞–∫—Ç–æ—Ä–∏–∞–ª n!"""
        if n < 0:
            raise ValueError("Factorial is not defined for negative numbers")
        return math.factorial(n)
    
    @staticmethod
    def permutations(n, r=None):
        """–†–∞–∑–º–µ—â–µ–Ω–∏—è P(n,r) = n!/(n-r)!"""
        if r is None:
            r = n
        if r > n or r < 0:
            return 0
        return math.factorial(n) // math.factorial(n - r)
    
    @staticmethod
    def combinations(n, r):
        """–°–æ—á–µ—Ç–∞–Ω–∏—è C(n,r) = n!/(r!(n-r)!)"""
        if r > n or r < 0:
            return 0
        return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))
    
    @staticmethod
    def stirling_second_kind(n, k):
        """–ß–∏—Å–ª–∞ –°—Ç–∏—Ä–ª–∏–Ω–≥–∞ –≤—Ç–æ—Ä–æ–≥–æ —Ä–æ–¥–∞ S(n,k)"""
        if n == 0 and k == 0:
            return 1
        if n == 0 or k == 0:
            return 0
        if k > n:
            return 0
        
        # –†–µ–∫—É—Ä—Ä–µ–Ω—Ç–Ω–∞—è —Ñ–æ—Ä–º—É–ª–∞: S(n,k) = k*S(n-1,k) + S(n-1,k-1)
        memo = {}
        
        def stirling_memo(n, k):
            if (n, k) in memo:
                return memo[(n, k)]
            
            if n == 0 and k == 0:
                result = 1
            elif n == 0 or k == 0:
                result = 0
            elif k > n:
                result = 0
            else:
                result = k * stirling_memo(n - 1, k) + stirling_memo(n - 1, k - 1)
            
            memo[(n, k)] = result
            return result
        
        return stirling_memo(n, k)
    
    @staticmethod
    def bell_number(n):
        """–ß–∏—Å–ª–∞ –ë–µ–ª–ª–∞ B(n) = —Å—É–º–º–∞ S(n,k) –¥–ª—è –≤—Å–µ—Ö k"""
        return sum(Combinatorics.stirling_second_kind(n, k) for k in range(n + 1))
    
    @staticmethod
    def catalan_number(n):
        """–ß–∏—Å–ª–∞ –ö–∞—Ç–∞–ª–∞–Ω–∞ C(n) = C(2n,n)/(n+1)"""
        return Combinatorics.combinations(2 * n, n) // (n + 1)
    
    @staticmethod
    def derangements(n):
        """–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–µ—Å–ø–æ—Ä—è–¥–∫–æ–≤ D(n)"""
        if n == 0:
            return 1
        if n == 1:
            return 0
        
        # –†–µ–∫—É—Ä—Ä–µ–Ω—Ç–Ω–∞—è —Ñ–æ—Ä–º—É–ª–∞: D(n) = (n-1)[D(n-1) + D(n-2)]
        d = [0] * (n + 1)
        d[0] = 1
        d[1] = 0
        
        for i in range(2, n + 1):
            d[i] = (i - 1) * (d[i - 1] + d[i - 2])
        
        return d[n]

# –ü—Ä–∏–º–µ—Ä: –∞–Ω–∞–ª–∏–∑ –ø–∞—Ä–æ–ª–µ–π
def password_analysis():
    """–ê–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –ø–∞—Ä–æ–ª–µ–π"""
    
    comb = Combinatorics()
    
    # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø–∞—Ä–æ–ª–µ–π
    lowercase = 26
    uppercase = 26
    digits = 10
    special = 32
    
    total_chars = lowercase + uppercase + digits + special
    
    print("–ê–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –ø–∞—Ä–æ–ª–µ–π:")
    
    for length in [6, 8, 10, 12]:
        # –í—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–∞—Ä–æ–ª–∏
        total_passwords = total_chars ** length
        
        # –¢–æ–ª—å–∫–æ —Å—Ç—Ä–æ—á–Ω—ã–µ –±—É–∫–≤—ã
        lowercase_only = lowercase ** length
        
        # –°–º–µ—à–∞–Ω–Ω—ã–µ (—Ö–æ—Ç—è –±—ã –æ–¥–Ω–∞ –∑–∞–≥–ª–∞–≤–Ω–∞—è)
        mixed_case = total_passwords - (lowercase ** length)
        
        print(f"\n–î–ª–∏–Ω–∞ {length} —Å–∏–º–≤–æ–ª–æ–≤:")
        print(f"  –í—Å–µ–≥–æ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø–∞—Ä–æ–ª–µ–π: {total_passwords:,}")
        print(f"  –¢–æ–ª—å–∫–æ —Å—Ç—Ä–æ—á–Ω—ã–µ: {lowercase_only:,}")
        print(f"  –°–æ —Å–º–µ—à–∞–Ω–Ω—ã–º —Ä–µ–≥–∏—Å—Ç—Ä–æ–º: {mixed_case:,}")
        
        # –í—Ä–µ–º—è –≤–∑–ª–æ–º–∞ (1 –º–ª–Ω –ø–æ–ø—ã—Ç–æ–∫ –≤ —Å–µ–∫—É–Ω–¥—É)
        attempts_per_second = 1_000_000
        worst_case_seconds = total_passwords / attempts_per_second
        worst_case_years = worst_case_seconds / (365 * 24 * 3600)
        
        print(f"  –í—Ä–µ–º—è –≤–∑–ª–æ–º–∞ (—Ö—É–¥—à–∏–π —Å–ª—É—á–∞–π): {worst_case_years:.2e} –ª–µ—Ç")

password_analysis()
```

### –ì–µ–Ω–µ—Ä–∏—Ä—É—é—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏

```python
import numpy as np
from scipy.special import comb

class GeneratingFunctions:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø—Ä–æ–∏–∑–≤–æ–¥—è—â–∏–º–∏ —Ñ—É–Ω–∫—Ü–∏—è–º–∏"""
    
    def __init__(self):
        self.coefficients = []
    
    def ordinary_generating_function(self, sequence, x_values):
        """–û–±—ã—á–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥—è—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
        results = []
        for x in x_values:
            result = sum(coeff * (x ** i) for i, coeff in enumerate(sequence))
            results.append(result)
        return results
    
    def exponential_generating_function(self, sequence, x_values):
        """–≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥—è—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
        results = []
        for x in x_values:
            result = sum(coeff * (x ** i) / math.factorial(i) 
                        for i, coeff in enumerate(sequence))
            results.append(result)
        return results
    
    def fibonacci_generating_function(self, n_terms):
        """–ü—Ä–æ–∏–∑–≤–æ–¥—è—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —á–∏—Å–µ–ª –§–∏–±–æ–Ω–∞—á—á–∏"""
        # F(x) = x / (1 - x - x^2)
        fib_sequence = [0, 1]
        for i in range(2, n_terms):
            fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2])
        
        return fib_sequence
    
    def partition_function(self, n):
        """–§—É–Ω–∫—Ü–∏—è —Ä–∞–∑–±–∏–µ–Ω–∏–π - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–æ—Å–æ–±–æ–≤ –∑–∞–ø–∏—Å–∞—Ç—å n –∫–∞–∫ —Å—É–º–º—É –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª"""
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ
        dp = [0] * (n + 1)
        dp[0] = 1
        
        for i in range(1, n + 1):
            for j in range(i, n + 1):
                dp[j] += dp[j - i]
        
        return dp[n]
    
    def coin_change_ways(self, coins, amount):
        """–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–æ—Å–æ–±–æ–≤ —Ä–∞–∑–º–µ–Ω—è—Ç—å —Å—É–º–º—É –º–æ–Ω–µ—Ç–∞–º–∏"""
        dp = [0] * (amount + 1)
        dp[0] = 1
        
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] += dp[i - coin]
        
        return dp[amount]

# –ü—Ä–∏–º–µ—Ä: –∞–Ω–∞–ª–∏–∑ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–Ω—ã—Ö –∑–∞–¥–∞—á
def combinatorial_problems():
    """–†–µ—à–µ–Ω–∏–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–Ω—ã—Ö –∑–∞–¥–∞—á"""
    
    gf = GeneratingFunctions()
    
    # –ó–∞–¥–∞—á–∞ –æ —Ä–∞–∑–±–∏–µ–Ω–∏—è—Ö
    print("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑–±–∏–µ–Ω–∏–π —á–∏—Å–µ–ª:")
    for n in range(1, 11):
        partitions = gf.partition_function(n)
        print(f"p({n}) = {partitions}")
    
    # –ó–∞–¥–∞—á–∞ –æ —Ä–∞–∑–º–µ–Ω–µ –º–æ–Ω–µ—Ç
    coins = [1, 5, 10, 25]  # –∫–æ–ø–µ–π–∫–∏, 5 –∫–æ–ø, 10 –∫–æ–ø, 25 –∫–æ–ø
    amounts = [10, 25, 50, 100]
    
    print("\n–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–æ—Å–æ–±–æ–≤ —Ä–∞–∑–º–µ–Ω—è—Ç—å —Å—É–º–º—É:")
    for amount in amounts:
        ways = gf.coin_change_ways(coins, amount)
        print(f"{amount} –∫–æ–ø–µ–µ–∫: {ways} —Å–ø–æ—Å–æ–±–æ–≤")
    
    # –ß–∏—Å–ª–∞ –§–∏–±–æ–Ω–∞—á—á–∏
    fib_seq = gf.fibonacci_generating_function(15)
    print(f"\n–ü–µ—Ä–≤—ã–µ 15 —á–∏—Å–µ–ª –§–∏–±–æ–Ω–∞—á—á–∏: {fib_seq}")

combinatorial_problems()
```

---

## –¢–µ–æ—Ä–∏—è —á–∏—Å–µ–ª

### –û—Å–Ω–æ–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã

```python
import random
from math import gcd

class NumberTheory:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ç–µ–æ—Ä–∏–µ–π —á–∏—Å–µ–ª"""
    
    @staticmethod
    def extended_gcd(a, b):
        """–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞"""
        if a == 0:
            return b, 0, 1
        
        gcd_val, x1, y1 = NumberTheory.extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        
        return gcd_val, x, y
    
    @staticmethod
    def mod_inverse(a, m):
        """–ú–æ–¥—É–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è –≤–µ–ª–∏—á–∏–Ω–∞"""
        gcd_val, x, _ = NumberTheory.extended_gcd(a, m)
        if gcd_val != 1:
            raise ValueError("–ú–æ–¥—É–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
        return (x % m + m) % m
    
    @staticmethod
    def fast_power(base, exp, mod):
        """–ë—ã—Å—Ç—Ä–æ–µ –≤–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å –ø–æ –º–æ–¥—É–ª—é"""
        result = 1
        base = base % mod
        
        while exp > 0:
            if exp % 2 == 1:
                result = (result * base) % mod
            exp = exp >> 1
            base = (base * base) % mod
        
        return result
    
    @staticmethod
    def is_prime(n, k=10):
        """–¢–µ—Å—Ç –ú–∏–ª–ª–µ—Ä–∞-–†–∞–±–∏–Ω–∞ –Ω–∞ –ø—Ä–æ—Å—Ç–æ—Ç—É"""
        if n < 2:
            return False
        if n == 2 or n == 3:
            return True
        if n % 2 == 0:
            return False
        
        # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º n-1 –∫–∞–∫ d * 2^r
        r = 0
        d = n - 1
        while d % 2 == 0:
            d //= 2
            r += 1
        
        # –ü—Ä–æ–≤–æ–¥–∏–º k —Ä–∞—É–Ω–¥–æ–≤ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        for _ in range(k):
            a = random.randrange(2, n - 1)
            x = NumberTheory.fast_power(a, d, n)
            
            if x == 1 or x == n - 1:
                continue
            
            for _ in range(r - 1):
                x = NumberTheory.fast_power(x, 2, n)
                if x == n - 1:
                    break
            else:
                return False
        
        return True
    
    @staticmethod
    def generate_prime(bits):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞ –∑–∞–¥–∞–Ω–Ω–æ–π –±–∏—Ç–Ω–æ—Å—Ç–∏"""
        while True:
            n = random.getrandbits(bits)
            n |= (1 << bits - 1) | 1  # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—à–∏–π –∏ –º–ª–∞–¥—à–∏–π –±–∏—Ç—ã
            if NumberTheory.is_prime(n):
                return n
    
    @staticmethod
    def factorize(n):
        """–§–∞–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —á–∏—Å–ª–∞ (–ø—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è)"""
        factors = []
        d = 2
        
        while d * d <= n:
            while n % d == 0:
                factors.append(d)
                n //= d
            d += 1
        
        if n > 1:
            factors.append(n)
        
        return factors
    
    @staticmethod
    def euler_phi(n):
        """–§—É–Ω–∫—Ü–∏—è –≠–π–ª–µ—Ä–∞ œÜ(n)"""
        if n == 1:
            return 1
        
        factors = NumberTheory.factorize(n)
        unique_factors = set(factors)
        
        result = n
        for p in unique_factors:
            result = result * (p - 1) // p
        
        return result
    
    @staticmethod
    def chinese_remainder_theorem(remainders, moduli):
        """–ö–∏—Ç–∞–π—Å–∫–∞—è —Ç–µ–æ—Ä–µ–º–∞ –æ–± –æ—Å—Ç–∞—Ç–∫–∞—Ö"""
        total = 0
        prod = 1
        
        for m in moduli:
            prod *= m
        
        for r, m in zip(remainders, moduli):
            p = prod // m
            total += r * NumberTheory.mod_inverse(p, m) * p
        
        return total % prod

# –ü—Ä–∏–º–µ—Ä: RSA –∫—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º–∞
def rsa_example():
    """–ü—Ä–∏–º–µ—Ä —Ä–∞–±–æ—Ç—ã RSA"""
    
    nt = NumberTheory()
    
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–≤–∞ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–ª–∞
    p = nt.generate_prime(512)
    q = nt.generate_prime(512)
    
    print(f"p = {p}")
    print(f"q = {q}")
    
    # –í—ã—á–∏—Å–ª—è–µ–º –º–æ–¥—É–ª—å
    n = p * q
    phi_n = (p - 1) * (q - 1)
    
    print(f"n = {n}")
    print(f"œÜ(n) = {phi_n}")
    
    # –í—ã–±–∏—Ä–∞–µ–º –æ—Ç–∫—Ä—ã—Ç—É—é —ç–∫—Å–ø–æ–Ω–µ–Ω—Ç—É
    e = 65537
    while gcd(e, phi_n) != 1:
        e += 2
    
    # –í—ã—á–∏—Å–ª—è–µ–º —Å–µ–∫—Ä–µ—Ç–Ω—É—é —ç–∫—Å–ø–æ–Ω–µ–Ω—Ç—É
    d = nt.mod_inverse(e, phi_n)
    
    print(f"–û—Ç–∫—Ä—ã—Ç—ã–π –∫–ª—é—á: (e={e}, n={n})")
    print(f"–°–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á: (d={d}, n={n})")
    
    # –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∏ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
    message = 42
    print(f"\n–°–æ–æ–±—â–µ–Ω–∏–µ: {message}")
    
    # –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ: c = m^e mod n
    ciphertext = nt.fast_power(message, e, n)
    print(f"–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ: {ciphertext}")
    
    # –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ: m = c^d mod n
    decrypted = nt.fast_power(ciphertext, d, n)
    print(f"–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ: {decrypted}")
    
    print(f"–ü—Ä–æ–≤–µ—Ä–∫–∞: {message == decrypted}")

# –ù–µ –∑–∞–ø—É—Å–∫–∞–µ–º rsa_example() –∑–¥–µ—Å—å, —Ç–∞–∫ –∫–∞–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –±–æ–ª—å—à–∏—Ö –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è
```

---

## –ê–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

### –ì—Ä—É–ø–ø—ã, –∫–æ–ª—å—Ü–∞, –ø–æ–ª—è

```python
class Group:
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏—Ö –≥—Ä—É–ø–ø"""
    
    def __init__(self, elements, operation):
        self.elements = set(elements)
        self.operation = operation
        self.identity = self.find_identity()
    
    def find_identity(self):
        """–ü–æ–∏—Å–∫ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞"""
        for e in self.elements:
            if all(self.operation(e, a) == a and self.operation(a, e) == a 
                   for a in self.elements):
                return e
        return None
    
    def is_group(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–∫—Å–∏–æ–º –≥—Ä—É–ø–ø—ã"""
        # –ó–∞–º–∫–Ω—É—Ç–æ—Å—Ç—å
        for a in self.elements:
            for b in self.elements:
                if self.operation(a, b) not in self.elements:
                    return False
        
        # –ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å
        for a in self.elements:
            for b in self.elements:
                for c in self.elements:
                    if (self.operation(self.operation(a, b), c) != 
                        self.operation(a, self.operation(b, c))):
                        return False
        
        # –ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
        if self.identity is None:
            return False
        
        # –û–±—Ä–∞—Ç–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
        for a in self.elements:
            has_inverse = False
            for b in self.elements:
                if (self.operation(a, b) == self.identity and 
                    self.operation(b, a) == self.identity):
                    has_inverse = True
                    break
            if not has_inverse:
                return False
        
        return True
    
    def find_inverse(self, element):
        """–ü–æ–∏—Å–∫ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞"""
        for b in self.elements:
            if (self.operation(element, b) == self.identity and 
                self.operation(b, element) == self.identity):
                return b
        return None
    
    def order(self):
        """–ü–æ—Ä—è–¥–æ–∫ –≥—Ä—É–ø–ø—ã"""
        return len(self.elements)
    
    def element_order(self, element):
        """–ü–æ—Ä—è–¥–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–∞"""
        current = element
        order = 1
        
        while current != self.identity:
            current = self.operation(current, element)
            order += 1
            if order > len(self.elements):  # –ó–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
                return float('inf')
        
        return order

# –ü—Ä–∏–º–µ—Ä: —Ü–∏–∫–ª–∏—á–µ—Å–∫–∞—è –≥—Ä—É–ø–ø–∞ Z_n
class CyclicGroup(Group):
    """–¶–∏–∫–ª–∏—á–µ—Å–∫–∞—è –≥—Ä—É–ø–ø–∞ Z_n"""
    
    def __init__(self, n):
        self.n = n
        elements = list(range(n))
        operation = lambda a, b: (a + b) % n
        super().__init__(elements, operation)
    
    def generate_subgroup(self, generator):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ–¥–≥—Ä—É–ø–ø—ã"""
        subgroup = set()
        current = 0  # –ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
        
        while current not in subgroup:
            subgroup.add(current)
            current = self.operation(current, generator)
        
        return subgroup

# –ü—Ä–∏–º–µ—Ä: —Ä–∞–±–æ—Ç–∞ —Å –∫–æ–Ω–µ—á–Ω—ã–º–∏ –ø–æ–ª—è–º–∏
class FiniteField:
    """–ö–æ–Ω–µ—á–Ω–æ–µ –ø–æ–ª–µ GF(p)"""
    
    def __init__(self, p):
        if not NumberTheory.is_prime(p):
            raise ValueError("p must be prime")
        self.p = p
        self.elements = list(range(p))
    
    def add(self, a, b):
        """–°–ª–æ–∂–µ–Ω–∏–µ –≤ –ø–æ–ª–µ"""
        return (a + b) % self.p
    
    def multiply(self, a, b):
        """–£–º–Ω–æ–∂–µ–Ω–∏–µ –≤ –ø–æ–ª–µ"""
        return (a * b) % self.p
    
    def inverse(self, a):
        """–ú—É–ª—å—Ç–∏–ø–ª–∏–∫–∞—Ç–∏–≤–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è"""
        if a == 0:
            raise ValueError("0 has no multiplicative inverse")
        return NumberTheory.mod_inverse(a, self.p)
    
    def divide(self, a, b):
        """–î–µ–ª–µ–Ω–∏–µ –≤ –ø–æ–ª–µ"""
        return self.multiply(a, self.inverse(b))
    
    def power(self, a, n):
        """–í–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å"""
        return NumberTheory.fast_power(a, n, self.p)

# –ü—Ä–∏–º–µ—Ä: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–æ–Ω–µ—á–Ω—ã—Ö –ø–æ–ª–µ–π –≤ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏
def finite_field_example():
    """–ü—Ä–∏–º–µ—Ä —Ä–∞–±–æ—Ç—ã —Å –∫–æ–Ω–µ—á–Ω—ã–º–∏ –ø–æ–ª—è–º–∏"""
    
    # –°–æ–∑–¥–∞–µ–º –ø–æ–ª–µ GF(7)
    field = FiniteField(7)
    
    print("–û–ø–µ—Ä–∞—Ü–∏–∏ –≤ –ø–æ–ª–µ GF(7):")
    print("–¢–∞–±–ª–∏—Ü–∞ —Å–ª–æ–∂–µ–Ω–∏—è:")
    for a in range(7):
        row = []
        for b in range(7):
            row.append(field.add(a, b))
        print(f"{a}: {row}")
    
    print("\n–¢–∞–±–ª–∏—Ü–∞ —É–º–Ω–æ–∂–µ–Ω–∏—è:")
    for a in range(1, 7):
        row = []
        for b in range(1, 7):
            row.append(field.multiply(a, b))
        print(f"{a}: {row}")
    
    print("\n–ú—É–ª—å—Ç–∏–ø–ª–∏–∫–∞—Ç–∏–≤–Ω—ã–µ –æ–±—Ä–∞—Ç–Ω—ã–µ:")
    for a in range(1, 7):
        inv = field.inverse(a)
        print(f"{a}^(-1) = {inv}, –ø—Ä–æ–≤–µ—Ä–∫–∞: {a} * {inv} = {field.multiply(a, inv)}")

finite_field_example()
```

---

## –ê–≤—Ç–æ–º–∞—Ç—ã –∏ —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–µ —è–∑—ã–∫–∏

### –ö–æ–Ω–µ—á–Ω—ã–µ –∞–≤—Ç–æ–º–∞—Ç—ã

```python
class FiniteAutomaton:
    """–î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–Ω–µ—á–Ω—ã–π –∞–≤—Ç–æ–º–∞—Ç"""
    
    def __init__(self, states, alphabet, transitions, start_state, accept_states):
        self.states = set(states)
        self.alphabet = set(alphabet)
        self.transitions = transitions
        self.start_state = start_state
        self.accept_states = set(accept_states)
    
    def process_string(self, string):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç—Ä–æ–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–æ–º"""
        current_state = self.start_state
        
        for symbol in string:
            if symbol not in self.alphabet:
                return False
            
            key = (current_state, symbol)
            if key not in self.transitions:
                return False
            
            current_state = self.transitions[key]
        
        return current_state in self.accept_states
    
    def minimize(self):
        """–ú–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è –∞–≤—Ç–æ–º–∞—Ç–∞"""
        # –ê–ª–≥–æ—Ä–∏—Ç–º –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
        # –†–∞–∑–¥–µ–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –Ω–∞ –ø—Ä–∏–Ω–∏–º–∞—é—â–∏–µ –∏ –Ω–µ–ø—Ä–∏–Ω–∏–º–∞—é—â–∏–µ
        accepting = self.accept_states
        non_accepting = self.states - accepting
        
        partitions = [accepting, non_accepting]
        
        changed = True
        while changed:
            changed = False
            new_partitions = []
            
            for partition in partitions:
                if len(partition) <= 1:
                    new_partitions.append(partition)
                    continue
                
                # –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞–∑–¥–µ–ª–∏—Ç—å partition
                subpartitions = self._split_partition(partition, partitions)
                
                if len(subpartitions) > 1:
                    changed = True
                    new_partitions.extend(subpartitions)
                else:
                    new_partitions.append(partition)
            
            partitions = new_partitions
        
        return self._build_minimized_automaton(partitions)
    
    def _split_partition(self, partition, all_partitions):
        """–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ partition –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–µ—Ä–µ—Ö–æ–¥–æ–≤"""
        if len(partition) <= 1:
            return [partition]
        
        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ –∏—Ö –ø–æ–≤–µ–¥–µ–Ω–∏—é
        groups = {}
        
        for state in partition:
            signature = []
            for symbol in sorted(self.alphabet):
                key = (state, symbol)
                if key in self.transitions:
                    next_state = self.transitions[key]
                    # –ù–∞—Ö–æ–¥–∏–º partition, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π next_state
                    for i, p in enumerate(all_partitions):
                        if next_state in p:
                            signature.append(i)
                            break
                else:
                    signature.append(-1)  # –ù–µ—Ç –ø–µ—Ä–µ—Ö–æ–¥–∞
            
            signature = tuple(signature)
            if signature not in groups:
                groups[signature] = set()
            groups[signature].add(state)
        
        return list(groups.values())
    
    def _build_minimized_automaton(self, partitions):
        """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –º–∏–Ω–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∞–≤—Ç–æ–º–∞—Ç–∞"""
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        state_map = {}
        new_states = []
        
        for i, partition in enumerate(partitions):
            new_state = f"q{i}"
            new_states.append(new_state)
            for old_state in partition:
                state_map[old_state] = new_state
        
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –ø–µ—Ä–µ—Ö–æ–¥—ã
        new_transitions = {}
        for (old_state, symbol), next_old_state in self.transitions.items():
            new_state = state_map[old_state]
            new_next_state = state_map[next_old_state]
            new_transitions[(new_state, symbol)] = new_next_state
        
        # –ù–æ–≤–æ–µ –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        new_start_state = state_map[self.start_state]
        
        # –ù–æ–≤—ã–µ –ø—Ä–∏–Ω–∏–º–∞—é—â–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        new_accept_states = set()
        for old_accept in self.accept_states:
            new_accept_states.add(state_map[old_accept])
        
        return FiniteAutomaton(
            new_states, self.alphabet, new_transitions, 
            new_start_state, new_accept_states
        )

# –ü—Ä–∏–º–µ—Ä: –∞–≤—Ç–æ–º–∞—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —á–µ—Ç–Ω–æ—Å—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –µ–¥–∏–Ω–∏—Ü
def even_ones_automaton():
    """–ê–≤—Ç–æ–º–∞—Ç, –ø—Ä–∏–Ω–∏–º–∞—é—â–∏–π —Å—Ç—Ä–æ–∫–∏ —Å —á–µ—Ç–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –µ–¥–∏–Ω–∏—Ü"""
    
    # –°–æ—Å—Ç–æ—è–Ω–∏—è: even (—á–µ—Ç–Ω–æ–µ), odd (–Ω–µ—á–µ—Ç–Ω–æ–µ)
    states = ['even', 'odd']
    alphabet = ['0', '1']
    
    # –ü–µ—Ä–µ—Ö–æ–¥—ã
    transitions = {
        ('even', '0'): 'even',
        ('even', '1'): 'odd',
        ('odd', '0'): 'odd',
        ('odd', '1'): 'even'
    }
    
    start_state = 'even'
    accept_states = ['even']
    
    automaton = FiniteAutomaton(states, alphabet, transitions, start_state, accept_states)
    
    # –¢–µ—Å—Ç–∏—Ä—É–µ–º
    test_strings = ['', '0', '1', '01', '11', '101', '1001', '110011']
    
    print("–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–≤—Ç–æ–º–∞—Ç–∞ –¥–ª—è —á–µ—Ç–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –µ–¥–∏–Ω–∏—Ü:")
    for string in test_strings:
        result = automaton.process_string(string)
        ones_count = string.count('1')
        expected = (ones_count % 2 == 0)
        print(f"'{string}': {result} (–µ–¥–∏–Ω–∏—Ü: {ones_count}, —á–µ—Ç–Ω–æ–µ: {expected})")

even_ones_automaton()
```

## üéØ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞–Ω–∏—è

### –ó–∞–¥–∞–Ω–∏–µ 1: –ì—Ä–∞—Ñ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
–°–æ–∑–¥–∞–π—Ç–µ –≥—Ä–∞—Ñ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –ø–∞–∫–µ—Ç–æ–≤ –∏ –Ω–∞–π–¥–∏—Ç–µ –ø–æ—Ä—è–¥–æ–∫ —É—Å—Ç–∞–Ω–æ–≤–∫–∏.

### –ó–∞–¥–∞–Ω–∏–µ 2: –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫—É—é —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—é –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–æ—Ä–∏–∏ —á–∏—Å–µ–ª.

### –ó–∞–¥–∞–Ω–∏–µ 3: –ê–Ω–∞–ª–∏–∑ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—Ä–æ–∏–∑–≤–æ–¥—è—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤.

### –ó–∞–¥–∞–Ω–∏–µ 4: –§–æ—Ä–º–∞–ª—å–Ω–∞—è –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è
–°–æ–∑–¥–∞–π—Ç–µ –∞–≤—Ç–æ–º–∞—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Å—Ç–æ–≥–æ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞.

---

## üîó –°–≤—è–∑–∞–Ω–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã

- [–ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑](./mathematical-analysis.md)
- [–ê–ª–≥–æ—Ä–∏—Ç–º—ã –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö](../algorithms-data-structures/README.md)
- [–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è](../technical-skills/security.md)
- [–¢–µ–æ—Ä–∏—è –≤—ã—á–∏—Å–ª–µ–Ω–∏–π](../algorithms-data-structures/computer-science-fundamentals.md) 