# –ê–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

## üéØ –¶–µ–ª—å –∫—É—Ä—Å–∞

–ò–∑—É—á–µ–Ω–∏–µ –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä (–≥—Ä—É–ø–ø, –∫–æ–ª–µ—Ü, –ø–æ–ª–µ–π) –∏ –∏—Ö –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–π –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏, –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –∏ –¥–∏—Å–∫—Ä–µ—Ç–Ω–æ–π –º–∞—Ç–µ–º–∞—Ç–∏–∫–µ.

## üìö –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

1. [–û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–Ω—è—Ç–∏—è](#–æ—Å–Ω–æ–≤–Ω—ã–µ-–ø–æ–Ω—è—Ç–∏—è)
2. [–ì—Ä—É–ø–ø—ã](#–≥—Ä—É–ø–ø—ã)
3. [–ö–æ–ª—å—Ü–∞](#–∫–æ–ª—å—Ü–∞)
4. [–ü–æ–ª—è](#–ø–æ–ª—è)
5. [–ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏](#–ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è-–≤-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏)
6. [–ö–æ–Ω–µ—á–Ω—ã–µ –ø–æ–ª—è](#–∫–æ–Ω–µ—á–Ω—ã–µ-–ø–æ–ª—è)

---

## –û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–Ω—è—Ç–∏—è

### –ë–∏–Ω–∞—Ä–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è

**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ:**
–ë–∏–Ω–∞—Ä–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è $*$ –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ $S$ - —ç—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è $* : S \times S \to S$.

**–°–≤–æ–π—Å—Ç–≤–∞ –æ–ø–µ—Ä–∞—Ü–∏–π:**

**–ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å:**
$$\forall a, b, c \in S: (a * b) * c = a * (b * c)$$

**–ö–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–æ—Å—Ç—å:**
$$\forall a, b \in S: a * b = b * a$$

**–°—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞:**
$$\exists e \in S: \forall a \in S: a * e = e * a = a$$

**–°—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞:**
$$\forall a \in S: \exists a^{-1} \in S: a * a^{-1} = a^{-1} * a = e$$

### –ú–∞–≥–º–∞, –ø–æ–ª—É–≥—Ä—É–ø–ø–∞, –º–æ–Ω–æ–∏–¥

**–ú–∞–≥–º–∞ (–≥—Ä—É–ø–ø–æ–∏–¥):**
$(S, *)$ - –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Å –±–∏–Ω–∞—Ä–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π.

**–ü–æ–ª—É–≥—Ä—É–ø–ø–∞:**
$(S, *)$ - –º–∞–≥–º–∞ —Å –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π.

**–ú–æ–Ω–æ–∏–¥:**
$(S, *, e)$ - –ø–æ–ª—É–≥—Ä—É–ø–ø–∞ —Å –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º.

```python
class Monoid:
    def __init__(self, elements, operation, identity):
        self.elements = elements
        self.operation = operation
        self.identity = identity
    
    def verify_associativity(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏"""
        for a in self.elements:
            for b in self.elements:
                for c in self.elements:
                    if self.operation(self.operation(a, b), c) != \
                       self.operation(a, self.operation(b, c)):
                        return False
        return True
    
    def verify_identity(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞"""
        for a in self.elements:
            if self.operation(a, self.identity) != a or \
               self.operation(self.identity, a) != a:
                return False
        return True

# –ü—Ä–∏–º–µ—Ä: –º–æ–Ω–æ–∏–¥ —Å—Ç—Ä–æ–∫ —Å –∫–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏–µ–π
string_monoid = Monoid(
    elements=["", "a", "b", "ab", "ba", "aa", "bb"],
    operation=lambda x, y: x + y,
    identity=""
)
```

---

## –ì—Ä—É–ø–ø—ã

### –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ

**–ì—Ä—É–ø–ø–∞** $(G, *)$ - —ç—Ç–æ –º–Ω–æ–∂–µ—Å—Ç–≤–æ $G$ —Å –±–∏–Ω–∞—Ä–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π $*$, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—â–µ–π:
1. **–ó–∞–º–∫–Ω—É—Ç–æ—Å—Ç—å**: $\forall a, b \in G: a * b \in G$
2. **–ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å**: $\forall a, b, c \in G: (a * b) * c = a * (b * c)$
3. **–ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç**: $\exists e \in G: \forall a \in G: a * e = e * a = a$
4. **–û–±—Ä–∞—Ç–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç**: $\forall a \in G: \exists a^{-1} \in G: a * a^{-1} = a^{-1} * a = e$

### –°–≤–æ–π—Å—Ç–≤–∞ –≥—Ä—É–ø–ø

**–ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞:**
$$\text{–ï—Å–ª–∏ } e_1, e_2 \text{ - –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã, —Ç–æ } e_1 = e_2$$

**–ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞:**
$$\text{–î–ª—è –∫–∞–∂–¥–æ–≥–æ } a \in G \text{ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π } a^{-1}$$

**–ó–∞–∫–æ–Ω —Å–æ–∫—Ä–∞—â–µ–Ω–∏—è:**
$$ab = ac \Rightarrow b = c$$
$$ba = ca \Rightarrow b = c$$

### –ü—Ä–∏–º–µ—Ä—ã –≥—Ä—É–ø–ø

**–ê–¥–¥–∏—Ç–∏–≤–Ω–∞—è –≥—Ä—É–ø–ø–∞ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª:**
$$(\mathbb{Z}, +, 0)$$

**–ú—É–ª—å—Ç–∏–ø–ª–∏–∫–∞—Ç–∏–≤–Ω–∞—è –≥—Ä—É–ø–ø–∞ –Ω–µ–Ω—É–ª–µ–≤—ã—Ö —Ä–∞—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª:**
$$(\mathbb{Q}^*, \cdot, 1)$$

**–ì—Ä—É–ø–ø–∞ –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–æ–∫ (—Å–∏–º–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è –≥—Ä—É–ø–ø–∞):**
$$S_n = \{\sigma: \{1, 2, \ldots, n\} \to \{1, 2, \ldots, n\} \mid \sigma \text{ –±–∏–µ–∫—Ü–∏—è}\}$$

### –¶–∏–∫–ª–∏—á–µ—Å–∫–∏–µ –≥—Ä—É–ø–ø—ã

**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ:**
–ì—Ä—É–ø–ø–∞ $G$ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–π, –µ—Å–ª–∏ $\exists g \in G$ —Ç–∞–∫–æ–π, —á—Ç–æ:
$$G = \langle g \rangle = \{g^n \mid n \in \mathbb{Z}\}$$

**–ü–æ—Ä—è–¥–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–∞:**
$$\text{ord}(g) = \min\{n \in \mathbb{N} \mid g^n = e\}$$

**–¢–µ–æ—Ä–µ–º–∞ –õ–∞–≥—Ä–∞–Ω–∂–∞:**
–î–ª—è –∫–æ–Ω–µ—á–Ω–æ–π –≥—Ä—É–ø–ø—ã $G$ –∏ –ø–æ–¥–≥—Ä—É–ø–ø—ã $H \leq G$:
$$|H| \text{ –¥–µ–ª–∏—Ç } |G|$$

```python
class Group:
    def __init__(self, elements, operation, identity):
        self.elements = elements
        self.operation = operation
        self.identity = identity
    
    def inverse(self, element):
        """–ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞"""
        for candidate in self.elements:
            if (self.operation(element, candidate) == self.identity and
                self.operation(candidate, element) == self.identity):
                return candidate
        return None
    
    def order(self, element):
        """–ü–æ—Ä—è–¥–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–∞"""
        current = element
        order = 1
        
        while current != self.identity:
            current = self.operation(current, element)
            order += 1
            
            if order > len(self.elements):
                return float('inf')  # –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫
        
        return order
    
    def generate_cyclic_subgroup(self, generator):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–π –ø–æ–¥–≥—Ä—É–ø–ø—ã"""
        subgroup = {self.identity}
        current = generator
        
        while current not in subgroup:
            subgroup.add(current)
            current = self.operation(current, generator)
        
        return subgroup

# –ü—Ä–∏–º–µ—Ä: –≥—Ä—É–ø–ø–∞ Z/5Z
def mod_add(a, b, n=5):
    return (a + b) % n

z5_group = Group(
    elements={0, 1, 2, 3, 4},
    operation=lambda a, b: mod_add(a, b, 5),
    identity=0
)
```

### –ì–æ–º–æ–º–æ—Ä—Ñ–∏–∑–º—ã

**–ì–æ–º–æ–º–æ—Ä—Ñ–∏–∑–º –≥—Ä—É–ø–ø:**
$$\phi: (G, *) \to (H, \circ)$$
$$\forall a, b \in G: \phi(a * b) = \phi(a) \circ \phi(b)$$

**–ò–∑–æ–º–æ—Ä—Ñ–∏–∑–º:**
–ë–∏–µ–∫—Ç–∏–≤–Ω—ã–π –≥–æ–º–æ–º–æ—Ä—Ñ–∏–∑–º.

**–ê–≤—Ç–æ–º–æ—Ä—Ñ–∏–∑–º:**
–ò–∑–æ–º–æ—Ä—Ñ–∏–∑–º –≥—Ä—É–ø–ø—ã –Ω–∞ —Å–µ–±—è.

**–Ø–¥—Ä–æ –∏ –æ–±—Ä–∞–∑:**
$$\ker(\phi) = \{g \in G \mid \phi(g) = e_H\}$$
$$\text{Im}(\phi) = \{\phi(g) \mid g \in G\}$$

**–ü–µ—Ä–≤–∞—è —Ç–µ–æ—Ä–µ–º–∞ –æ–± –∏–∑–æ–º–æ—Ä—Ñ–∏–∑–º–µ:**
$$G / \ker(\phi) \cong \text{Im}(\phi)$$

---

## –ö–æ–ª—å—Ü–∞

### –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ

**–ö–æ–ª—å—Ü–æ** $(R, +, \cdot)$ - —ç—Ç–æ –º–Ω–æ–∂–µ—Å—Ç–≤–æ $R$ —Å –¥–≤—É–º—è –±–∏–Ω–∞—Ä–Ω—ã–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—â–∏–º–∏:
1. $(R, +)$ - –∞–±–µ–ª–µ–≤–∞ –≥—Ä—É–ø–ø–∞
2. $(R, \cdot)$ - –ø–æ–ª—É–≥—Ä—É–ø–ø–∞
3. **–î–∏—Å—Ç—Ä–∏–±—É—Ç–∏–≤–Ω–æ—Å—Ç—å**: 
   $$a \cdot (b + c) = a \cdot b + a \cdot c$$
   $$(a + b) \cdot c = a \cdot c + b \cdot c$$

### –¢–∏–ø—ã –∫–æ–ª–µ—Ü

**–ö–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–æ–µ –∫–æ–ª—å—Ü–æ:**
$$\forall a, b \in R: a \cdot b = b \cdot a$$

**–ö–æ–ª—å—Ü–æ —Å –µ–¥–∏–Ω–∏—Ü–µ–π:**
$$\exists 1 \in R: \forall a \in R: a \cdot 1 = 1 \cdot a = a$$

**–û–±–ª–∞—Å—Ç—å —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏:**
–ö–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–æ–µ –∫–æ–ª—å—Ü–æ —Å –µ–¥–∏–Ω–∏—Ü–µ–π –±–µ–∑ –¥–µ–ª–∏—Ç–µ–ª–µ–π –Ω—É–ª—è:
$$a \cdot b = 0 \Rightarrow a = 0 \text{ –∏–ª–∏ } b = 0$$

### –ü—Ä–∏–º–µ—Ä—ã –∫–æ–ª–µ—Ü

**–ö–æ–ª—å—Ü–æ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª:**
$$(\mathbb{Z}, +, \cdot)$$

**–ö–æ–ª—å—Ü–æ –º–Ω–æ–≥–æ—á–ª–µ–Ω–æ–≤:**
$$R[x] = \{a_0 + a_1x + a_2x^2 + \ldots + a_nx^n \mid a_i \in R\}$$

**–ö–æ–ª—å—Ü–æ –º–∞—Ç—Ä–∏—Ü:**
$$M_n(R) = \{A \mid A \text{ - –º–∞—Ç—Ä–∏—Ü–∞ } n \times n \text{ –Ω–∞–¥ } R\}$$

### –ò–¥–µ–∞–ª—ã

**–õ–µ–≤—ã–π –∏–¥–µ–∞–ª:**
$$I \subseteq R \text{ —Ç–∞–∫–æ–π, —á—Ç–æ } \forall a \in I, r \in R: ra \in I$$

**–ü—Ä–∞–≤—ã–π –∏–¥–µ–∞–ª:**
$$I \subseteq R \text{ —Ç–∞–∫–æ–π, —á—Ç–æ } \forall a \in I, r \in R: ar \in I$$

**–î–≤—É—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π –∏–¥–µ–∞–ª:**
–û–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –ª–µ–≤—ã–π –∏ –ø—Ä–∞–≤—ã–π –∏–¥–µ–∞–ª.

**–ì–ª–∞–≤–Ω—ã–π –∏–¥–µ–∞–ª:**
$$\langle a \rangle = \{ra + as + \sum_{i} r_i a s_i \mid r, s, r_i, s_i \in R\}$$

### –§–∞–∫—Ç–æ—Ä–∫–æ–ª—å—Ü–∞

**–§–∞–∫—Ç–æ—Ä–∫–æ–ª—å—Ü–æ:**
$$R/I = \{r + I \mid r \in R\}$$

**–û–ø–µ—Ä–∞—Ü–∏–∏:**
$$(r + I) + (s + I) = (r + s) + I$$
$$(r + I) \cdot (s + I) = (rs) + I$$

```python
class Ring:
    def __init__(self, elements, add, mult, zero, one=None):
        self.elements = elements
        self.add = add
        self.mult = mult
        self.zero = zero
        self.one = one
    
    def is_commutative(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏ —É–º–Ω–æ–∂–µ–Ω–∏—è"""
        for a in self.elements:
            for b in self.elements:
                if self.mult(a, b) != self.mult(b, a):
                    return False
        return True
    
    def has_zero_divisors(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–µ–ª–∏—Ç–µ–ª–∏ –Ω—É–ª—è"""
        for a in self.elements:
            if a == self.zero:
                continue
            for b in self.elements:
                if b == self.zero:
                    continue
                if self.mult(a, b) == self.zero:
                    return True
        return False
    
    def is_field(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∫–æ–ª—å—Ü–æ –ø–æ–ª–µ–º"""
        if not self.is_commutative():
            return False
        
        # –ö–∞–∂–¥—ã–π –Ω–µ–Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å –æ–±—Ä–∞—Ç–Ω—ã–π
        for a in self.elements:
            if a == self.zero:
                continue
            
            has_inverse = False
            for b in self.elements:
                if self.mult(a, b) == self.one:
                    has_inverse = True
                    break
            
            if not has_inverse:
                return False
        
        return True

# –ü—Ä–∏–º–µ—Ä: –∫–æ–ª—å—Ü–æ Z/6Z
def mod_add(a, b, n=6):
    return (a + b) % n

def mod_mult(a, b, n=6):
    return (a * b) % n

z6_ring = Ring(
    elements={0, 1, 2, 3, 4, 5},
    add=lambda a, b: mod_add(a, b, 6),
    mult=lambda a, b: mod_mult(a, b, 6),
    zero=0,
    one=1
)
```

---

## –ü–æ–ª—è

### –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ

**–ü–æ–ª–µ** $(F, +, \cdot)$ - —ç—Ç–æ –∫–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–æ–µ –∫–æ–ª—å—Ü–æ —Å –µ–¥–∏–Ω–∏—Ü–µ–π, –≤ –∫–æ—Ç–æ—Ä–æ–º –∫–∞–∂–¥—ã–π –Ω–µ–Ω—É–ª–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –æ–±—Ä–∞—Ç–∏–º:
$$\forall a \in F, a \neq 0: \exists a^{-1} \in F: a \cdot a^{-1} = 1$$

### –°–≤–æ–π—Å—Ç–≤–∞ –ø–æ–ª–µ–π

**–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—è:**
$$\text{char}(F) = \min\{n \in \mathbb{N} \mid n \cdot 1 = 0\}$$

–ï—Å–ª–∏ —Ç–∞–∫–æ–≥–æ $n$ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Ç–æ $\text{char}(F) = 0$.

**–û—Å–Ω–æ–≤–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞:**
- –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—è –ª–∏–±–æ 0, –ª–∏–±–æ –ø—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ
- –ö–∞–∂–¥–æ–µ –∫–æ–Ω–µ—á–Ω–æ–µ –ø–æ–ª–µ –∏–º–µ–µ—Ç $p^n$ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ –ø—Ä–æ—Å—Ç–æ–≥–æ $p$

### –ü—Ä–∏–º–µ—Ä—ã –ø–æ–ª–µ–π

**–ü–æ–ª–µ —Ä–∞—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª:**
$$(\mathbb{Q}, +, \cdot)$$

**–ü–æ–ª–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª:**
$$(\mathbb{R}, +, \cdot)$$

**–ü–æ–ª–µ –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã—Ö —á–∏—Å–µ–ª:**
$$(\mathbb{C}, +, \cdot)$$

**–ö–æ–Ω–µ—á–Ω–æ–µ –ø–æ–ª–µ:**
$$\mathbb{F}_p = \mathbb{Z}/p\mathbb{Z} \text{ –¥–ª—è –ø—Ä–æ—Å—Ç–æ–≥–æ } p$$

### –†–∞—Å—à–∏—Ä–µ–Ω–∏—è –ø–æ–ª–µ–π

**–ü—Ä–æ—Å—Ç–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ:**
$$F(\alpha) = \{f(\alpha) \mid f \in F[x]\}$$

**–ê–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ:**
$\alpha$ –∞–ª–≥–µ–±—Ä–∞–∏—á–µ–Ω –Ω–∞–¥ $F$, –µ—Å–ª–∏ $\exists f \in F[x], f \neq 0: f(\alpha) = 0$.

**–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –º–Ω–æ–≥–æ—á–ª–µ–Ω:**
–ú–Ω–æ–≥–æ—á–ª–µ–Ω –Ω–∞–∏–º–µ–Ω—å—à–µ–π —Å—Ç–µ–ø–µ–Ω–∏, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ $\alpha$ —è–≤–ª—è–µ—Ç—Å—è –∫–æ—Ä–Ω–µ–º.

```python
def extended_gcd(a, b):
    """–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞"""
    if a == 0:
        return b, 0, 1
    
    gcd, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    
    return gcd, x, y

def mod_inverse(a, m):
    """–ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –ø–æ –º–æ–¥—É–ª—é"""
    gcd, x, _ = extended_gcd(a, m)
    
    if gcd != 1:
        return None  # –û–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    
    return x % m

class FiniteField:
    def __init__(self, p):
        """–ö–æ–Ω–µ—á–Ω–æ–µ –ø–æ–ª–µ F_p"""
        self.p = p
        self.elements = list(range(p))
    
    def add(self, a, b):
        return (a + b) % self.p
    
    def mult(self, a, b):
        return (a * b) % self.p
    
    def inverse(self, a):
        if a == 0:
            return None
        return mod_inverse(a, self.p)
    
    def power(self, a, n):
        """–ë—ã—Å—Ç—Ä–æ–µ –≤–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å"""
        result = 1
        a = a % self.p
        
        while n > 0:
            if n % 2 == 1:
                result = (result * a) % self.p
            n = n // 2
            a = (a * a) % self.p
        
        return result

# –ü—Ä–∏–º–µ—Ä: –ø–æ–ª–µ F_7
F7 = FiniteField(7)
print(f"3 + 5 = {F7.add(3, 5)}")  # 1
print(f"3 * 5 = {F7.mult(3, 5)}")  # 1
print(f"3^(-1) = {F7.inverse(3)}")  # 5
```

---

## –ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏

### –ö–æ–¥—ã –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—à–∏–±–æ–∫

**–ö–æ–¥—ã –†–∏–¥–∞-–°–æ–ª–æ–º–æ–Ω–∞:**
–ò—Å–ø–æ–ª—å–∑—É—é—Ç –∫–æ–Ω–µ—á–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.

**–ú–Ω–æ–≥–æ—á–ª–µ–Ω –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è:**
$$p(x) = \sum_{i=0}^{k-1} m_i x^i$$

**–ö–æ–¥–æ–≤–æ–µ —Å–ª–æ–≤–æ:**
$$c = (p(\alpha^0), p(\alpha^1), \ldots, p(\alpha^{n-1}))$$

–≥–¥–µ $\alpha$ - –ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –ø–æ–ª—è.

### –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è

**–≠–ª–ª–∏–ø—Ç–∏—á–µ—Å–∫–∏–µ –∫—Ä–∏–≤—ã–µ:**
$$y^2 = x^3 + ax + b$$

**–°–ª–æ–∂–µ–Ω–∏–µ —Ç–æ—á–µ–∫:**
–î–ª—è —Ç–æ—á–µ–∫ $P = (x_1, y_1)$ –∏ $Q = (x_2, y_2)$:

–ï—Å–ª–∏ $P \neq Q$:
$$\lambda = \frac{y_2 - y_1}{x_2 - x_1}$$

–ï—Å–ª–∏ $P = Q$:
$$\lambda = \frac{3x_1^2 + a}{2y_1}$$

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**
$$P + Q = (x_3, y_3)$$
$$x_3 = \lambda^2 - x_1 - x_2$$
$$y_3 = \lambda(x_1 - x_3) - y_1$$

### –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ

**–ü–æ–ª–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ–µ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ:**
$$h(s) = \sum_{i=0}^{n-1} s[i] \cdot p^i \bmod m$$

–≥–¥–µ $p$ - –ø—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ, $m$ - –º–æ–¥—É–ª—å.

```python
def polynomial_hash(s, p=31, m=10**9 + 7):
    """–ü–æ–ª–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ–µ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ"""
    hash_value = 0
    p_power = 1
    
    for char in s:
        hash_value = (hash_value + ord(char) * p_power) % m
        p_power = (p_power * p) % m
    
    return hash_value

def rolling_hash(s, pattern_length, p=31, m=10**9 + 7):
    """–°–∫–æ–ª—å–∑—è—â–µ–µ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏"""
    if len(s) < pattern_length:
        return []
    
    # –í—ã—á–∏—Å–ª—è–µ–º p^(pattern_length-1) mod m
    p_power = pow(p, pattern_length - 1, m)
    
    # –•–µ—à –ø–µ—Ä–≤–æ–≥–æ –æ–∫–Ω–∞
    current_hash = 0
    for i in range(pattern_length):
        current_hash = (current_hash + ord(s[i]) * pow(p, i, m)) % m
    
    hashes = [current_hash]
    
    # –°–∫–æ–ª—å–∑—è—â–µ–µ –æ–∫–Ω–æ
    for i in range(pattern_length, len(s)):
        # –£–±–∏—Ä–∞–µ–º –ª–µ–≤—ã–π —Å–∏–º–≤–æ–ª
        current_hash = (current_hash - ord(s[i - pattern_length])) % m
        current_hash = (current_hash * pow(p, -1, m)) % m
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∞–≤—ã–π —Å–∏–º–≤–æ–ª
        current_hash = (current_hash + ord(s[i]) * p_power) % m
        
        hashes.append(current_hash)
    
    return hashes
```

---

## –ö–æ–Ω–µ—á–Ω—ã–µ –ø–æ–ª—è

### –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∫–æ–Ω–µ—á–Ω—ã—Ö –ø–æ–ª–µ–π

**–ü–æ–ª–µ $\mathbb{F}_{p^n}$:**
–ö–æ–Ω—Å—Ç—Ä—É–∏—Ä—É–µ—Ç—Å—è –∫–∞–∫ $\mathbb{F}_p[x] / \langle f(x) \rangle$, –≥–¥–µ $f(x)$ - –Ω–µ–ø—Ä–∏–≤–æ–¥–∏–º—ã–π –º–Ω–æ–≥–æ—á–ª–µ–Ω —Å—Ç–µ–ø–µ–Ω–∏ $n$.

**–ü—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã:**
–≠–ª–µ–º–µ–Ω—Ç $\alpha$ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–º, –µ—Å–ª–∏ $\text{ord}(\alpha) = p^n - 1$.

### –ê–ª–≥–æ—Ä–∏—Ç–º—ã

**–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ–ø—Ä–∏–≤–æ–¥–∏–º–æ—Å—Ç–∏:**
–ú–Ω–æ–≥–æ—á–ª–µ–Ω $f(x)$ —Å—Ç–µ–ø–µ–Ω–∏ $n$ –Ω–µ–ø—Ä–∏–≤–æ–¥–∏–º –Ω–∞–¥ $\mathbb{F}_p$, –µ—Å–ª–∏:
$$\gcd(f(x), x^{p^i} - x) = 1 \text{ –¥–ª—è –≤—Å–µ—Ö } i = 1, 2, \ldots, \lfloor n/2 \rfloor$$

**–ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –∫–æ—Ä–Ω–µ–π:**
–ê–ª–≥–æ—Ä–∏—Ç–º –ö–∞–Ω—Ç–æ—Ä–∞-–¶–∞—Å—Å–µ–Ω—Ö–∞—É–∑–∞ –¥–ª—è —Ñ–∞–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –º–Ω–æ–≥–æ—á–ª–µ–Ω–æ–≤.

```python
class GaloisField:
    def __init__(self, p, irreducible_poly):
        """–ü–æ–ª–µ –ì–∞–ª—É–∞ GF(p^n)"""
        self.p = p
        self.irreducible_poly = irreducible_poly
        self.degree = len(irreducible_poly) - 1
    
    def add(self, a, b):
        """–°–ª–æ–∂–µ–Ω–∏–µ –º–Ω–æ–≥–æ—á–ª–µ–Ω–æ–≤"""
        result = [0] * max(len(a), len(b))
        
        for i in range(len(a)):
            result[i] = (result[i] + a[i]) % self.p
        
        for i in range(len(b)):
            result[i] = (result[i] + b[i]) % self.p
        
        return self.normalize(result)
    
    def mult(self, a, b):
        """–£–º–Ω–æ–∂–µ–Ω–∏–µ –º–Ω–æ–≥–æ—á–ª–µ–Ω–æ–≤ —Å –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ–º"""
        # –û–±—ã—á–Ω–æ–µ —É–º–Ω–æ–∂–µ–Ω–∏–µ –º–Ω–æ–≥–æ—á–ª–µ–Ω–æ–≤
        result = [0] * (len(a) + len(b) - 1)
        
        for i in range(len(a)):
            for j in range(len(b)):
                result[i + j] = (result[i + j] + a[i] * b[j]) % self.p
        
        # –ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –ø–æ –Ω–µ–ø—Ä–∏–≤–æ–¥–∏–º–æ–º—É –º–Ω–æ–≥–æ—á–ª–µ–Ω—É
        return self.reduce(result)
    
    def reduce(self, poly):
        """–ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –ø–æ –Ω–µ–ø—Ä–∏–≤–æ–¥–∏–º–æ–º—É –º–Ω–æ–≥–æ—á–ª–µ–Ω—É"""
        while len(poly) >= len(self.irreducible_poly):
            if poly[-1] == 0:
                poly.pop()
                continue
            
            # –î–µ–ª–µ–Ω–∏–µ –Ω–∞ —Å—Ç–∞—Ä—à–∏–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç
            coeff = poly[-1]
            
            # –í—ã—á–∏—Ç–∞–Ω–∏–µ –∫—Ä–∞—Ç–Ω–æ–≥–æ –Ω–µ–ø—Ä–∏–≤–æ–¥–∏–º–æ–≥–æ –º–Ω–æ–≥–æ—á–ª–µ–Ω–∞
            for i in range(len(self.irreducible_poly)):
                idx = len(poly) - len(self.irreducible_poly) + i
                if idx >= 0:
                    poly[idx] = (poly[idx] - coeff * self.irreducible_poly[i]) % self.p
            
            # –£–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ä—à–∏–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç
            poly.pop()
        
        return self.normalize(poly)
    
    def normalize(self, poly):
        """–£–±–∏—Ä–∞–µ–º –≤–µ–¥—É—â–∏–µ –Ω—É–ª–∏"""
        while len(poly) > 1 and poly[-1] == 0:
            poly.pop()
        return poly if poly else [0]

# –ü—Ä–∏–º–µ—Ä: GF(2^3) —Å –Ω–µ–ø—Ä–∏–≤–æ–¥–∏–º—ã–º –º–Ω–æ–≥–æ—á–ª–µ–Ω–æ–º x^3 + x + 1
gf8 = GaloisField(2, [1, 1, 0, 1])  # x^3 + x + 1

# –≠–ª–µ–º–µ–Ω—Ç—ã –ø–æ–ª—è –∫–∞–∫ –º–Ω–æ–≥–æ—á–ª–µ–Ω—ã
a = [1, 0, 1]  # x^2 + 1
b = [0, 1, 1]  # x^2 + x

print(f"a + b = {gf8.add(a, b)}")
print(f"a * b = {gf8.mult(a, b)}")
```

---

## –°–≤—è–∑–∞–Ω–Ω—ã–µ —Ç–µ–º—ã

- [[number-theory]] - –¢–µ–æ—Ä–∏—è —á–∏—Å–µ–ª
- [[discrete-mathematics]] - –î–∏—Å–∫—Ä–µ—Ç–Ω–∞—è –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞
- [[cryptography]] - –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è
- [[linear-algebra]] - –õ–∏–Ω–µ–π–Ω–∞—è –∞–ª–≥–µ–±—Ä–∞

---

*–ê–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –æ–±–µ—Å–ø–µ—á–∏–≤–∞—é—Ç —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—É—é –æ—Å–Ω–æ–≤—É –¥–ª—è –º–Ω–æ–≥–∏—Ö –æ–±–ª–∞—Å—Ç–µ–π –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∏, –≤–∫–ª—é—á–∞—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—é, –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ, –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω—É—é –∞–ª–≥–µ–±—Ä—É –∏ —Ñ–æ—Ä–º–∞–ª—å–Ω—É—é –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—é.* 