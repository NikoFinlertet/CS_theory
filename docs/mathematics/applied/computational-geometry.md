# –í—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è

## üéØ –¶–µ–ª—å –∫—É—Ä—Å–∞

–ò–∑—É—á–µ–Ω–∏–µ –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –∏ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –æ—Å–Ω–æ–≤ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π, –∏–≥—Ä –∏ –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–≥–æ –∑—Ä–µ–Ω–∏—è.

## üìö –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

1. [–û—Å–Ω–æ–≤—ã –≥–µ–æ–º–µ—Ç—Ä–∏–∏](#–æ—Å–Ω–æ–≤—ã-–≥–µ–æ–º–µ—Ç—Ä–∏–∏)
2. [–ê–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–∞ —Ç–æ—á–∫–∞—Ö](#–∞–ª–≥–æ—Ä–∏—Ç–º—ã-–Ω–∞-—Ç–æ—á–∫–∞—Ö)
3. [–ê–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–∞ –æ—Ç—Ä–µ–∑–∫–∞—Ö](#–∞–ª–≥–æ—Ä–∏—Ç–º—ã-–Ω–∞-–æ—Ç—Ä–µ–∑–∫–∞—Ö)
4. [–ü–æ–ª–∏–≥–æ–Ω—ã –∏ –º–Ω–æ–≥–æ—É–≥–æ–ª—å–Ω–∏–∫–∏](#–ø–æ–ª–∏–≥–æ–Ω—ã-–∏-–º–Ω–æ–≥–æ—É–≥–æ–ª—å–Ω–∏–∫–∏)
5. [3D –≥–µ–æ–º–µ—Ç—Ä–∏—è](#3d-–≥–µ–æ–º–µ—Ç—Ä–∏—è)
6. [–ö–æ–º–ø—å—é—Ç–µ—Ä–Ω–∞—è –≥—Ä–∞—Ñ–∏–∫–∞](#–∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–∞—è-–≥—Ä–∞—Ñ–∏–∫–∞)

---

## –û—Å–Ω–æ–≤—ã –≥–µ–æ–º–µ—Ç—Ä–∏–∏

### –°–∏—Å—Ç–µ–º—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç

**–î–µ–∫–∞—Ä—Ç–æ–≤–∞ —Å–∏—Å—Ç–µ–º–∞:**
$$P = (x, y)$$

**–ü–æ–ª—è—Ä–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞:**
$$P = (r, \theta)$$
$$x = r \cos \theta$$
$$y = r \sin \theta$$

**–ü–µ—Ä–µ—Ö–æ–¥ –º–µ–∂–¥—É —Å–∏—Å—Ç–µ–º–∞–º–∏:**
$$r = \sqrt{x^2 + y^2}$$
$$\theta = \arctan\left(\frac{y}{x}\right)$$

### –í–µ–∫—Ç–æ—Ä—ã

**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞:**
$$\vec{v} = \langle x, y \rangle$$

**–î–ª–∏–Ω–∞ –≤–µ–∫—Ç–æ—Ä–∞:**
$$|\vec{v}| = \sqrt{x^2 + y^2}$$

**–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è:**
$$\hat{v} = \frac{\vec{v}}{|\vec{v}|} = \left\langle \frac{x}{|\vec{v}|}, \frac{y}{|\vec{v}|} \right\rangle$$

**–°–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ:**
$$\vec{a} \cdot \vec{b} = a_x b_x + a_y b_y = |\vec{a}| |\vec{b}| \cos \theta$$

**–í–µ–∫—Ç–æ—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ (2D):**
$$\vec{a} \times \vec{b} = a_x b_y - a_y b_x$$

### –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

```python
import math
import numpy as np

class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def length(self):
        return math.sqrt(self.x**2 + self.y**2)
    
    def normalize(self):
        length = self.length()
        if length > 0:
            return Vector2D(self.x / length, self.y / length)
        return Vector2D(0, 0)
    
    def dot(self, other):
        return self.x * other.x + self.y * other.y
    
    def cross(self, other):
        return self.x * other.y - self.y * other.x
    
    def angle_between(self, other):
        dot_product = self.dot(other)
        lengths = self.length() * other.length()
        return math.acos(dot_product / lengths)
```

---

## –ê–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–∞ —Ç–æ—á–∫–∞—Ö

### –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏

**–ï–≤–∫–ª–∏–¥–æ–≤–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ:**
$$d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$$

**–ú–∞–Ω—Ö—ç—Ç—Ç–µ–Ω—Å–∫–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ:**
$$d = |x_2 - x_1| + |y_2 - y_1|$$

### –í—ã–ø—É–∫–ª–∞—è –æ–±–æ–ª–æ—á–∫–∞

**–ê–ª–≥–æ—Ä–∏—Ç–º –ì—Ä—ç—Ö–µ–º–∞:**
1. –ù–∞–π—Ç–∏ —Ç–æ—á–∫—É —Å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π y-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ–π
2. –û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ—á–∫–∏ –ø–æ –ø–æ–ª—è—Ä–Ω–æ–º—É —É–≥–ª—É
3. –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≤—ã–ø—É–∫–ª—É—é –æ–±–æ–ª–æ—á–∫—É

**–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–≤–æ—Ä–æ—Ç–∞:**
$$\text{cross}(p_1, p_2, p_3) = (p_2.x - p_1.x)(p_3.y - p_1.y) - (p_2.y - p_1.y)(p_3.x - p_1.x)$$

```python
def convex_hull_graham(points):
    def cross_product(o, a, b):
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])
    
    # –ù–∞–π—Ç–∏ –Ω–∞—á–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É
    start = min(points, key=lambda p: (p[1], p[0]))
    
    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –ø–æ–ª—è—Ä–Ω–æ–º—É —É–≥–ª—É
    def polar_angle(p):
        return math.atan2(p[1] - start[1], p[0] - start[0])
    
    sorted_points = sorted(points, key=polar_angle)
    
    # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≤—ã–ø—É–∫–ª–æ–π –æ–±–æ–ª–æ—á–∫–∏
    hull = []
    for p in sorted_points:
        while len(hull) > 1 and cross_product(hull[-2], hull[-1], p) <= 0:
            hull.pop()
        hull.append(p)
    
    return hull
```

### –¢—Ä–∏–∞–Ω–≥—É–ª—è—Ü–∏—è –î–µ–ª–æ–Ω–µ

**–ö—Ä–∏—Ç–µ—Ä–∏–π –î–µ–ª–æ–Ω–µ:**
–¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —Ç—Ä–∏–∞–Ω–≥—É–ª—è—Ü–∏–∏ –î–µ–ª–æ–Ω–µ, –µ—Å–ª–∏ –µ–≥–æ –æ–ø–∏—Å–∞–Ω–Ω–∞—è –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥—Ä—É–≥–∏—Ö —Ç–æ—á–µ–∫.

**–¢–µ—Å—Ç –≤ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏:**
$$\begin{vmatrix}
x_1 & y_1 & x_1^2 + y_1^2 & 1 \\
x_2 & y_2 & x_2^2 + y_2^2 & 1 \\
x_3 & y_3 & x_3^2 + y_3^2 & 1 \\
x_4 & y_4 & x_4^2 + y_4^2 & 1
\end{vmatrix} > 0$$

---

## –ê–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–∞ –æ—Ç—Ä–µ–∑–∫–∞—Ö

### –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –æ—Ç—Ä–µ–∑–∫–æ–≤

**–ü–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ:**
$$P(t) = P_1 + t(P_2 - P_1), \quad t \in [0, 1]$$

**–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –¥–≤—É—Ö –æ—Ç—Ä–µ–∑–∫–æ–≤:**
–û—Ç—Ä–µ–∑–∫–∏ $AB$ –∏ $CD$ –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è, –µ—Å–ª–∏:
$$\text{orientation}(A, B, C) \neq \text{orientation}(A, B, D)$$
$$\text{orientation}(C, D, A) \neq \text{orientation}(C, D, B)$$

```python
def segments_intersect(p1, q1, p2, q2):
    def orientation(p, q, r):
        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
        if val == 0:
            return 0  # –∫–æ–ª–ª–∏–Ω–µ–∞—Ä–Ω—ã–µ
        return 1 if val > 0 else 2  # –ø–æ —á–∞—Å–æ–≤–æ–π –∏–ª–∏ –ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π
    
    def on_segment(p, q, r):
        return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and
                q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))
    
    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)
    
    # –û–±—â–∏–π —Å–ª—É—á–∞–π
    if o1 != o2 and o3 != o4:
        return True
    
    # –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–ª—É—á–∞–∏
    if (o1 == 0 and on_segment(p1, p2, q1)) or \
       (o2 == 0 and on_segment(p1, q2, q1)) or \
       (o3 == 0 and on_segment(p2, p1, q2)) or \
       (o4 == 0 and on_segment(p2, q1, q2)):
        return True
    
    return False
```

### –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –¥–æ –æ—Ç—Ä–µ–∑–∫–∞

**–§–æ—Ä–º—É–ª–∞:**
$$d = \frac{|(x_2 - x_1)(y_1 - y_0) - (x_1 - x_0)(y_2 - y_1)|}{\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}}$$

---

## –ü–æ–ª–∏–≥–æ–Ω—ã –∏ –º–Ω–æ–≥–æ—É–≥–æ–ª—å–Ω–∏–∫–∏

### –ü–ª–æ—â–∞–¥—å –º–Ω–æ–≥–æ—É–≥–æ–ª—å–Ω–∏–∫–∞

**–§–æ—Ä–º—É–ª–∞ –ì–∞—É—Å—Å–∞:**
$$S = \frac{1}{2} \left| \sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i) \right|$$

### –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç–∏ —Ç–æ—á–∫–∏ –ø–æ–ª–∏–≥–æ–Ω—É

**–ê–ª–≥–æ—Ä–∏—Ç–º —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏ –ª—É—á–µ–π:**
```python
def point_in_polygon(point, polygon):
    x, y = point
    n = len(polygon)
    inside = False
    
    p1x, p1y = polygon[0]
    for i in range(1, n + 1):
        p2x, p2y = polygon[i % n]
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                    if p1x == p2x or x <= xinters:
                        inside = not inside
        p1x, p1y = p2x, p2y
    
    return inside
```

### –í—ã–ø—É–∫–ª–æ—Å—Ç—å –ø–æ–ª–∏–≥–æ–Ω–∞

**–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã–ø—É–∫–ª–æ—Å—Ç–∏:**
–ü–æ–ª–∏–≥–æ–Ω –≤—ã–ø—É–∫–ª, –µ—Å–ª–∏ –≤—Å–µ –ø–æ–≤–æ—Ä–æ—Ç—ã –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π –∑–Ω–∞–∫.

---

## 3D –≥–µ–æ–º–µ—Ç—Ä–∏—è

### –¢—Ä–µ—Ö–º–µ—Ä–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã

**–í–µ–∫—Ç–æ—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ:**
$$\vec{a} \times \vec{b} = \begin{vmatrix}
\mathbf{i} & \mathbf{j} & \mathbf{k} \\
a_x & a_y & a_z \\
b_x & b_y & b_z
\end{vmatrix}$$

$$= (a_y b_z - a_z b_y)\mathbf{i} - (a_x b_z - a_z b_x)\mathbf{j} + (a_x b_y - a_y b_x)\mathbf{k}$$

### –ü–ª–æ—Å–∫–æ—Å—Ç–∏

**–£—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–ª–æ—Å–∫–æ—Å—Ç–∏:**
$$ax + by + cz + d = 0$$

**–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –¥–æ –ø–ª–æ—Å–∫–æ—Å—Ç–∏:**
$$d = \frac{|ax_0 + by_0 + cz_0 + d|}{\sqrt{a^2 + b^2 + c^2}}$$

### –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –ª—É—á–∞ —Å –ø–ª–æ—Å–∫–æ—Å—Ç—å—é

**–ü–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–æ–µ —É—Ä–∞–≤–Ω–µ–Ω–∏–µ –ª—É—á–∞:**
$$\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}$$

**–¢–æ—á–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è:**
$$t = -\frac{\mathbf{n} \cdot \mathbf{o} + d}{\mathbf{n} \cdot \mathbf{d}}$$

---

## –ö–æ–º–ø—å—é—Ç–µ—Ä–Ω–∞—è –≥—Ä–∞—Ñ–∏–∫–∞

### –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏

**–ú–∞—Ç—Ä–∏—Ü–∞ –ø–æ–≤–æ—Ä–æ—Ç–∞ (2D):**
$$R(\theta) = \begin{pmatrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta
\end{pmatrix}$$

**–ú–∞—Ç—Ä–∏—Ü–∞ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è:**
$$S(s_x, s_y) = \begin{pmatrix}
s_x & 0 \\
0 & s_y
\end{pmatrix}$$

**–ú–∞—Ç—Ä–∏—Ü–∞ –ø–µ—Ä–µ–Ω–æ—Å–∞ (–≥–æ–º–æ–≥–µ–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã):**
$$T(t_x, t_y) = \begin{pmatrix}
1 & 0 & t_x \\
0 & 1 & t_y \\
0 & 0 & 1
\end{pmatrix}$$

### –ü—Ä–æ–µ–∫—Ü–∏–∏

**–û—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–µ–∫—Ü–∏—è:**
$$P_{ortho} = \begin{pmatrix}
\frac{2}{r-l} & 0 & 0 & -\frac{r+l}{r-l} \\
0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b} \\
0 & 0 & \frac{-2}{f-n} & -\frac{f+n}{f-n} \\
0 & 0 & 0 & 1
\end{pmatrix}$$

**–ü–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω–∞—è –ø—Ä–æ–µ–∫—Ü–∏—è:**
$$P_{persp} = \begin{pmatrix}
\frac{2n}{r-l} & 0 & \frac{r+l}{r-l} & 0 \\
0 & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0 \\
0 & 0 & -\frac{f+n}{f-n} & -\frac{2fn}{f-n} \\
0 & 0 & -1 & 0
\end{pmatrix}$$

### –ö—Ä–∏–≤—ã–µ –ë–µ–∑—å–µ

**–ö—É–±–∏—á–µ—Å–∫–∞—è –∫—Ä–∏–≤–∞—è –ë–µ–∑—å–µ:**
$$B(t) = (1-t)^3 P_0 + 3(1-t)^2 t P_1 + 3(1-t) t^2 P_2 + t^3 P_3$$

**–ú–∞—Ç—Ä–∏—á–Ω–∞—è —Ñ–æ—Ä–º–∞:**
$$B(t) = \begin{pmatrix} 1 & t & t^2 & t^3 \end{pmatrix} \begin{pmatrix}
1 & 0 & 0 & 0 \\
-3 & 3 & 0 & 0 \\
3 & -6 & 3 & 0 \\
-1 & 3 & -3 & 1
\end{pmatrix} \begin{pmatrix}
P_0 \\ P_1 \\ P_2 \\ P_3
\end{pmatrix}$$

### –ê–ª–≥–æ—Ä–∏—Ç–º—ã —Ä–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏

**–ê–ª–≥–æ—Ä–∏—Ç–º –ë—Ä–µ–∑–µ–Ω—Ö–µ–º–∞ –¥–ª—è –æ—Ç—Ä–µ–∑–∫–∞:**
```python
def bresenham_line(x0, y0, x1, y1):
    points = []
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    
    sx = 1 if x0 < x1 else -1
    sy = 1 if y0 < y1 else -1
    
    err = dx - dy
    
    while True:
        points.append((x0, y0))
        
        if x0 == x1 and y0 == y1:
            break
            
        e2 = 2 * err
        
        if e2 > -dy:
            err -= dy
            x0 += sx
            
        if e2 < dx:
            err += dx
            y0 += sy
    
    return points
```

**–ê–ª–≥–æ—Ä–∏—Ç–º –∑–∞–ª–∏–≤–∫–∏:**
```python
def flood_fill(image, x, y, new_color, old_color):
    if x < 0 or x >= len(image) or y < 0 or y >= len(image[0]):
        return
    if image[x][y] != old_color:
        return
    
    image[x][y] = new_color
    
    # –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∑–∞–ª–∏–≤–∞–µ–º —Å–æ—Å–µ–¥–Ω–∏–µ –ø–∏–∫—Å–µ–ª–∏
    flood_fill(image, x + 1, y, new_color, old_color)
    flood_fill(image, x - 1, y, new_color, old_color)
    flood_fill(image, x, y + 1, new_color, old_color)
    flood_fill(image, x, y - 1, new_color, old_color)
```

---

## –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ –∏–≥—Ä–∞—Ö

### –î–µ—Ç–µ–∫—Ü–∏—è –∫–æ–ª–ª–∏–∑–∏–π

**AABB (Axis-Aligned Bounding Box):**
```python
def aabb_collision(box1, box2):
    return (box1.min_x <= box2.max_x and box1.max_x >= box2.min_x and
            box1.min_y <= box2.max_y and box1.max_y >= box2.min_y)
```

**–û–∫—Ä—É–∂–Ω–æ—Å—Ç–∏:**
```python
def circle_collision(circle1, circle2):
    distance = math.sqrt((circle1.x - circle2.x)**2 + (circle1.y - circle2.y)**2)
    return distance <= (circle1.radius + circle2.radius)
```

### –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

**Quadtree:**
```python
class QuadTree:
    def __init__(self, boundary, capacity):
        self.boundary = boundary
        self.capacity = capacity
        self.points = []
        self.divided = False
        
    def subdivide(self):
        x, y, w, h = self.boundary
        nw = QuadTree((x, y, w/2, h/2), self.capacity)
        ne = QuadTree((x + w/2, y, w/2, h/2), self.capacity)
        sw = QuadTree((x, y + h/2, w/2, h/2), self.capacity)
        se = QuadTree((x + w/2, y + h/2, w/2, h/2), self.capacity)
        
        self.northwest = nw
        self.northeast = ne
        self.southwest = sw
        self.southeast = se
        
        self.divided = True
```

---

## –°–≤—è–∑–∞–Ω–Ω—ã–µ —Ç–µ–º—ã

- [[linear-algebra-computation]] - –ú–∞—Ç—Ä–∏—Ü—ã –∏ –≤–µ–∫—Ç–æ—Ä—ã
- [[physics-fundamentals]] - –§–∏–∑–∏—á–µ—Å–∫–∏–µ —Å–∏–º—É–ª—è—Ü–∏–∏
- [[optimization]] - –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
- [[numerical-methods]] - –ß–∏—Å–ª–µ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã –≤ –≥–µ–æ–º–µ—Ç—Ä–∏–∏

---

*–ì–µ–æ–º–µ—Ç—Ä–∏—è - —ç—Ç–æ –æ—Å–Ω–æ–≤–∞ –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω—ã—Ö –æ—Ç–Ω–æ—à–µ–Ω–∏–π –∏ —Å–æ–∑–¥–∞–Ω–∏—è –≤–∏–∑—É–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π. –ó–Ω–∞–Ω–∏–µ –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –∏–≥—Ä, –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏—Ö —Ä–µ–¥–∞–∫—Ç–æ—Ä–æ–≤ –∏ —Å–∏—Å—Ç–µ–º –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–≥–æ –∑—Ä–µ–Ω–∏—è.* 