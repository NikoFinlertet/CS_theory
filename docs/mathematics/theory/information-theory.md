# –¢–µ–æ—Ä–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏

## üéØ –¶–µ–ª—å –∫—É—Ä—Å–∞

–ò–∑—É—á–µ–Ω–∏–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –æ—Å–Ω–æ–≤ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –ø–µ—Ä–µ–¥–∞—á–∏ –¥–∞–Ω–Ω—ã—Ö —Å –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º –≤ —Å–∂–∞—Ç–∏–∏ –¥–∞–Ω–Ω—ã—Ö, –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –∏ –º–∞—à–∏–Ω–Ω–æ–º –æ–±—É—á–µ–Ω–∏–∏.

## üìö –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

1. [–û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–Ω—è—Ç–∏—è](#–æ—Å–Ω–æ–≤–Ω—ã–µ-–ø–æ–Ω—è—Ç–∏—è)
2. [–≠–Ω—Ç—Ä–æ–ø–∏—è –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è](#—ç–Ω—Ç—Ä–æ–ø–∏—è-–∏-–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è)
3. [–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤](#–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ-–∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤)
4. [–ö–∞–Ω–∞–ª—å–Ω–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ](#–∫–∞–Ω–∞–ª—å–Ω–æ–µ-–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ)
5. [–í–∑–∞–∏–º–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è](#–≤–∑–∞–∏–º–Ω–∞—è-–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è)
6. [–ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤ ML](#–ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è-–≤-ml)

---

## –û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–Ω—è—Ç–∏—è

### –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏

**–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤ —Å–æ–±—ã—Ç–∏–∏:**
$$I(x) = -\log_2 P(x)$$

–≥–¥–µ $P(x)$ - –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —Å–æ–±—ã—Ç–∏—è $x$.

**–ï–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è:**
- **–ë–∏—Ç (bit)** - –ª–æ–≥–∞—Ä–∏—Ñ–º –ø–æ –æ—Å–Ω–æ–≤–∞–Ω–∏—é 2
- **–ù–∞—Ç (nat)** - –ª–æ–≥–∞—Ä–∏—Ñ–º –ø–æ –æ—Å–Ω–æ–≤–∞–Ω–∏—é $e$
- **–î–∏—Ç (dit)** - –ª–æ–≥–∞—Ä–∏—Ñ–º –ø–æ –æ—Å–Ω–æ–≤–∞–Ω–∏—é 10

### –≠–Ω—Ç—Ä–æ–ø–∏—è

**–≠–Ω—Ç—Ä–æ–ø–∏—è –¥–∏—Å–∫—Ä–µ—Ç–Ω–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞:**
$$H(X) = -\sum_{i=1}^{n} p_i \log_2 p_i$$

**–°–≤–æ–π—Å—Ç–≤–∞ —ç–Ω—Ç—Ä–æ–ø–∏–∏:**
- $H(X) \geq 0$ (–Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å)
- $H(X) = 0$ —Ç–æ–≥–¥–∞ –∏ —Ç–æ–ª—å–∫–æ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ $X$ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω
- $H(X) \leq \log_2 n$ (–º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è –¥–ª—è —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è)

### –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

```python
import math
import numpy as np
from collections import Counter

def entropy(data):
    """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ —ç–Ω—Ç—Ä–æ–ø–∏–∏ –¥–ª—è –¥–∏—Å–∫—Ä–µ—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
    if not data:
        return 0
    
    # –ü–æ–¥—Å—á–µ—Ç —á–∞—Å—Ç–æ—Ç
    counts = Counter(data)
    probabilities = [count / len(data) for count in counts.values()]
    
    # –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —ç–Ω—Ç—Ä–æ–ø–∏–∏
    entropy = 0
    for p in probabilities:
        if p > 0:
            entropy -= p * math.log2(p)
    
    return entropy

def information_content(probability):
    """–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤ —Å–æ–±—ã—Ç–∏–∏"""
    if probability <= 0:
        return float('inf')
    return -math.log2(probability)

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
data = ['A', 'B', 'A', 'C', 'A', 'B', 'A']
print(f"–≠–Ω—Ç—Ä–æ–ø–∏—è: {entropy(data):.3f} –±–∏—Ç")
print(f"–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –≤ —Å–æ–±—ã—Ç–∏–∏ 'A': {information_content(4/7):.3f} –±–∏—Ç")
```

---

## –≠–Ω—Ç—Ä–æ–ø–∏—è –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è

### –£—Å–ª–æ–≤–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è

**–£—Å–ª–æ–≤–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è:**
$$H(Y|X) = \sum_{x} P(x) H(Y|X=x)$$

$$H(Y|X) = -\sum_{x,y} P(x,y) \log_2 P(y|x)$$

**–¶–µ–ø–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ:**
$$H(X,Y) = H(X) + H(Y|X)$$

### –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è

**–î–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—è –ö—É–ª—å–±–∞–∫–∞-–õ–µ–π–±–ª–µ—Ä–∞:**
$$D_{KL}(P||Q) = \sum_{x} P(x) \log_2 \frac{P(x)}{Q(x)}$$

**–°–≤–æ–π—Å—Ç–≤–∞:**
- $D_{KL}(P||Q) \geq 0$
- $D_{KL}(P||Q) = 0$ —Ç–æ–≥–¥–∞ –∏ —Ç–æ–ª—å–∫–æ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ $P = Q$

### –ö—Ä–æ—Å—Å-—ç–Ω—Ç—Ä–æ–ø–∏—è

**–ö—Ä–æ—Å—Å-—ç–Ω—Ç—Ä–æ–ø–∏—è:**
$$H(P,Q) = -\sum_{x} P(x) \log_2 Q(x)$$

**–°–≤—è–∑—å —Å KL-–¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–µ–π:**
$$H(P,Q) = H(P) + D_{KL}(P||Q)$$

```python
def conditional_entropy(X, Y):
    """–£—Å–ª–æ–≤–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è H(Y|X)"""
    joint_counts = Counter(zip(X, Y))
    x_counts = Counter(X)
    
    conditional_entropy = 0
    for (x, y), joint_count in joint_counts.items():
        p_xy = joint_count / len(X)
        p_x = x_counts[x] / len(X)
        p_y_given_x = joint_count / x_counts[x]
        
        conditional_entropy -= p_xy * math.log2(p_y_given_x)
    
    return conditional_entropy

def kl_divergence(P, Q):
    """KL-–¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è–º–∏"""
    divergence = 0
    for p, q in zip(P, Q):
        if p > 0 and q > 0:
            divergence += p * math.log2(p / q)
    return divergence

def cross_entropy(P, Q):
    """–ö—Ä–æ—Å—Å-—ç–Ω—Ç—Ä–æ–ø–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è–º–∏"""
    cross_ent = 0
    for p, q in zip(P, Q):
        if p > 0 and q > 0:
            cross_ent -= p * math.log2(q)
    return cross_ent
```

---

## –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤

### –ö–æ–¥—ã —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –¥–ª–∏–Ω–æ–π

**–ù–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ –ö—Ä–∞—Ñ—Ç–∞:**
–î–ª—è –ø—Ä–µ—Ñ–∏–∫—Å–Ω–æ–≥–æ –∫–æ–¥–∞ —Å –¥–ª–∏–Ω–∞–º–∏ –∫–æ–¥–æ–≤—ã—Ö —Å–ª–æ–≤ $l_1, l_2, \ldots, l_n$:
$$\sum_{i=1}^{n} 2^{-l_i} \leq 1$$

**–¢–µ–æ—Ä–µ–º–∞ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∏—Å—Ç–æ—á–Ω–∏–∫–∞:**
–î–ª—è –ª—é–±–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ —Å —ç–Ω—Ç—Ä–æ–ø–∏–µ–π $H(X)$ –∏ –ª—é–±–æ–≥–æ $\epsilon > 0$ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∫–æ–¥, —Ç–∞–∫–æ–π —á—Ç–æ:
$$H(X) \leq \bar{L} < H(X) + \epsilon$$

–≥–¥–µ $\bar{L}$ - —Å—Ä–µ–¥–Ω—è—è –¥–ª–∏–Ω–∞ –∫–æ–¥–æ–≤–æ–≥–æ —Å–ª–æ–≤–∞.

### –ö–æ–¥ –•–∞—Ñ—Ñ–º–∞–Ω–∞

**–ê–ª–≥–æ—Ä–∏—Ç–º –•–∞—Ñ—Ñ–º–∞–Ω–∞:**
1. –°–æ–∑–¥–∞—Ç—å –ª–∏—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤ —Å –∏—Ö —á–∞—Å—Ç–æ—Ç–∞–º–∏
2. –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –¥–µ—Ä–µ–≤–æ —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö, –æ–±—ä–µ–¥–∏–Ω—è—è —É–∑–ª—ã —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ —á–∞—Å—Ç–æ—Ç–∞–º–∏
3. –ù–∞–∑–Ω–∞—á–∏—Ç—å –∫–æ–¥—ã: 0 –¥–ª—è –ª–µ–≤—ã—Ö –≤–µ—Ç–≤–µ–π, 1 –¥–ª—è –ø—Ä–∞–≤—ã—Ö

```python
import heapq
from collections import defaultdict

class Node:
    def __init__(self, freq, symbol=None, left=None, right=None):
        self.freq = freq
        self.symbol = symbol
        self.left = left
        self.right = right
    
    def __lt__(self, other):
        return self.freq < other.freq

def huffman_coding(frequencies):
    """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∫–æ–¥–∞ –•–∞—Ñ—Ñ–º–∞–Ω–∞"""
    if len(frequencies) == 1:
        return {list(frequencies.keys())[0]: '0'}
    
    # –°–æ–∑–¥–∞–Ω–∏–µ –∫—É—á–∏ –∏–∑ —É–∑–ª–æ–≤
    heap = [Node(freq, symbol) for symbol, freq in frequencies.items()]
    heapq.heapify(heap)
    
    # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –¥–µ—Ä–µ–≤–∞
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        
        merged = Node(left.freq + right.freq, left=left, right=right)
        heapq.heappush(heap, merged)
    
    # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–¥–æ–≤
    root = heap[0]
    codes = {}
    
    def extract_codes(node, code=''):
        if node.symbol is not None:
            codes[node.symbol] = code
        else:
            extract_codes(node.left, code + '0')
            extract_codes(node.right, code + '1')
    
    extract_codes(root)
    return codes

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
frequencies = {'A': 45, 'B': 13, 'C': 12, 'D': 16, 'E': 9, 'F': 5}
codes = huffman_coding(frequencies)
print("–ö–æ–¥—ã –•–∞—Ñ—Ñ–º–∞–Ω–∞:")
for symbol, code in codes.items():
    print(f"{symbol}: {code}")
```

### –ê—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ

**–ü—Ä–∏–Ω—Ü–∏–ø:**
–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Å–∏–º–≤–æ–ª–æ–≤ –∫–∞–∫ –æ–¥–Ω–æ–≥–æ —á–∏—Å–ª–∞ –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ $[0, 1)$.

**–ê–ª–≥–æ—Ä–∏—Ç–º:**
1. –ù–∞—á–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª: $[0, 1)$
2. –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ —Ä–∞–∑–¥–µ–ª–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—è–º
3. –í—ã–±—Ä–∞—Ç—å –ø–æ–¥–∏–Ω—Ç–µ—Ä–≤–∞–ª, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Å–∏–º–≤–æ–ª—É
4. –ü–æ–≤—Ç–æ—Ä–∏—Ç—å –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–∏–º–≤–æ–ª–∞

```python
def arithmetic_encode(message, probabilities):
    """–ê—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ"""
    # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∫—É–º—É–ª—è—Ç–∏–≤–Ω—ã—Ö –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π
    cumulative = {}
    cum_prob = 0
    for symbol in sorted(probabilities.keys()):
        cumulative[symbol] = cum_prob
        cum_prob += probabilities[symbol]
    
    # –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ
    low = 0.0
    high = 1.0
    
    for symbol in message:
        range_size = high - low
        high = low + range_size * (cumulative[symbol] + probabilities[symbol])
        low = low + range_size * cumulative[symbol]
    
    # –í–æ–∑–≤—Ä–∞—Ç –ª—é–±–æ–≥–æ —á–∏—Å–ª–∞ –≤ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ
    return (low + high) / 2

def arithmetic_decode(code, probabilities, length):
    """–ê—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–æ–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ"""
    # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∫—É–º—É–ª—è—Ç–∏–≤–Ω—ã—Ö –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π
    cumulative = {}
    cum_prob = 0
    for symbol in sorted(probabilities.keys()):
        cumulative[symbol] = cum_prob
        cum_prob += probabilities[symbol]
    
    # –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ
    decoded = []
    low = 0.0
    high = 1.0
    
    for _ in range(length):
        range_size = high - low
        scaled_value = (code - low) / range_size
        
        # –ù–∞–π—Ç–∏ —Å–∏–º–≤–æ–ª
        for symbol in sorted(probabilities.keys()):
            if cumulative[symbol] <= scaled_value < cumulative[symbol] + probabilities[symbol]:
                decoded.append(symbol)
                # –û–±–Ω–æ–≤–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª
                high = low + range_size * (cumulative[symbol] + probabilities[symbol])
                low = low + range_size * cumulative[symbol]
                break
    
    return ''.join(decoded)
```

---

## –ö–∞–Ω–∞–ª—å–Ω–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ

### –ü—Ä–æ–ø—É—Å–∫–Ω–∞—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –∫–∞–Ω–∞–ª–∞

**–ü—Ä–æ–ø—É—Å–∫–Ω–∞—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å:**
$$C = \max_{P(X)} I(X;Y)$$

–≥–¥–µ $I(X;Y)$ - –≤–∑–∞–∏–º–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –º–µ–∂–¥—É –≤—Ö–æ–¥–æ–º –∏ –≤—ã—Ö–æ–¥–æ–º –∫–∞–Ω–∞–ª–∞.

**–î–ª—è –¥–≤–æ–∏—á–Ω–æ–≥–æ —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞:**
$$C = 1 - H(p)$$

–≥–¥–µ $p$ - –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –æ—à–∏–±–∫–∏, $H(p) = -p \log_2 p - (1-p) \log_2 (1-p)$.

### –ö–æ–¥—ã –¥–ª—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—à–∏–±–æ–∫

**–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –•–µ–º–º–∏–Ω–≥–∞:**
$$d(x,y) = \sum_{i=1}^{n} \mathbf{1}_{x_i \neq y_i}$$

**–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –∫–æ–¥–∞:**
$$d_{min} = \min_{x \neq y} d(x,y)$$

**–ì—Ä–∞–Ω–∏—Ü–∞ –•–µ–º–º–∏–Ω–≥–∞:**
$$M \leq \frac{2^n}{\sum_{i=0}^{t} \binom{n}{i}}$$

–≥–¥–µ $M$ - —á–∏—Å–ª–æ –∫–æ–¥–æ–≤—ã—Ö —Å–ª–æ–≤, $t$ - —á–∏—Å–ª–æ –∏—Å–ø—Ä–∞–≤–ª—è–µ–º—ã—Ö –æ—à–∏–±–æ–∫.

```python
def hamming_distance(x, y):
    """–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –•–µ–º–º–∏–Ω–≥–∞ –º–µ–∂–¥—É –¥–≤—É–º—è —Å—Ç—Ä–æ–∫–∞–º–∏"""
    return sum(c1 != c2 for c1, c2 in zip(x, y))

def generate_hamming_7_4():
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–¥–∞ –•–µ–º–º–∏–Ω–≥–∞ (7,4)"""
    # –ü–æ—Ä–æ–∂–¥–∞—é—â–∞—è –º–∞—Ç—Ä–∏—Ü–∞
    G = np.array([
        [1, 0, 0, 0, 1, 1, 0],
        [0, 1, 0, 0, 1, 0, 1],
        [0, 0, 1, 0, 0, 1, 1],
        [0, 0, 0, 1, 1, 1, 1]
    ])
    
    # –ü—Ä–æ–≤–µ—Ä–æ—á–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞
    H = np.array([
        [1, 1, 0, 1, 1, 0, 0],
        [1, 0, 1, 1, 0, 1, 0],
        [0, 1, 1, 1, 0, 0, 1]
    ])
    
    return G, H

def hamming_encode(data, G):
    """–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é –∫–æ–¥–∞ –•–µ–º–º–∏–Ω–≥–∞"""
    return np.dot(data, G) % 2

def hamming_decode(received, H):
    """–î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –æ–¥–∏–Ω–æ—á–Ω—ã—Ö –æ—à–∏–±–æ–∫"""
    syndrome = np.dot(H, received) % 2
    
    if np.sum(syndrome) == 0:
        # –ù–µ—Ç –æ—à–∏–±–æ–∫
        return received[:4]  # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–µ –±–∏—Ç—ã
    else:
        # –ù–∞–π—Ç–∏ –ø–æ–∑–∏—Ü–∏—é –æ—à–∏–±–∫–∏
        error_pos = 0
        for i in range(3):
            if syndrome[i] == 1:
                error_pos += 2**i
        
        # –ò—Å–ø—Ä–∞–≤–∏—Ç—å –æ—à–∏–±–∫—É
        corrected = received.copy()
        corrected[error_pos - 1] = 1 - corrected[error_pos - 1]
        
        return corrected[:4]
```

---

## –í–∑–∞–∏–º–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è

### –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ

**–í–∑–∞–∏–º–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:**
$$I(X;Y) = \sum_{x,y} P(x,y) \log_2 \frac{P(x,y)}{P(x)P(y)}$$

**–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ —Ñ–æ—Ä–º—ã:**
$$I(X;Y) = H(X) - H(X|Y)$$
$$I(X;Y) = H(Y) - H(Y|X)$$
$$I(X;Y) = H(X) + H(Y) - H(X,Y)$$

### –°–≤–æ–π—Å—Ç–≤–∞

**–û—Å–Ω–æ–≤–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞:**
- $I(X;Y) = I(Y;X)$ (—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ—Å—Ç—å)
- $I(X;Y) \geq 0$ (–Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å)
- $I(X;X) = H(X)$ (–∞–≤—Ç–æ–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è)
- $I(X;Y) = 0$ —Ç–æ–≥–¥–∞ –∏ —Ç–æ–ª—å–∫–æ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ $X$ –∏ $Y$ –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã

```python
def mutual_information(X, Y):
    """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤–∑–∞–∏–º–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"""
    # –ü–æ–¥—Å—á–µ—Ç —Å–æ–≤–º–µ—Å—Ç–Ω—ã—Ö –∏ –º–∞—Ä–≥–∏–Ω–∞–ª—å–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç
    joint_counts = Counter(zip(X, Y))
    x_counts = Counter(X)
    y_counts = Counter(Y)
    
    n = len(X)
    mi = 0
    
    for (x, y), joint_count in joint_counts.items():
        p_xy = joint_count / n
        p_x = x_counts[x] / n
        p_y = y_counts[y] / n
        
        mi += p_xy * math.log2(p_xy / (p_x * p_y))
    
    return mi

def normalized_mutual_information(X, Y):
    """–ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –≤–∑–∞–∏–º–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è"""
    mi = mutual_information(X, Y)
    h_x = entropy(X)
    h_y = entropy(Y)
    
    return mi / math.sqrt(h_x * h_y)
```

---

## –ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤ ML

### –í—ã–±–æ—Ä –ø—Ä–∏–∑–Ω–∞–∫–æ–≤

**–ö—Ä–∏—Ç–µ—Ä–∏–π –≤–∑–∞–∏–º–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏:**
–í—ã–±–∏—Ä–∞–µ–º –ø—Ä–∏–∑–Ω–∞–∫–∏ —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –≤–∑–∞–∏–º–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π —Å —Ü–µ–ª–µ–≤–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.

```python
def feature_selection_mi(X, y, k=10):
    """–í—ã–±–æ—Ä k –ª—É—á—à–∏—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –ø–æ –≤–∑–∞–∏–º–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"""
    scores = []
    
    for i in range(X.shape[1]):
        mi = mutual_information(X[:, i], y)
        scores.append((i, mi))
    
    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —É–±—ã–≤–∞–Ω–∏—é –≤–∑–∞–∏–º–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    scores.sort(key=lambda x: x[1], reverse=True)
    
    # –í–æ–∑–≤—Ä–∞—Ç –∏–Ω–¥–µ–∫—Å–æ–≤ k –ª—É—á—à–∏—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
    return [idx for idx, _ in scores[:k]]
```

### –û—Ü–µ–Ω–∫–∞ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏

**Adjusted Mutual Information (AMI):**
$$AMI = \frac{MI - E[MI]}{\max(H(X), H(Y)) - E[MI]}$$

–≥–¥–µ $E[MI]$ - –æ–∂–∏–¥–∞–µ–º–∞—è –≤–∑–∞–∏–º–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ —Ä–∞–∑–±–∏–µ–Ω–∏—è.

### –†–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏—è –≤ –Ω–µ–π—Ä–æ–Ω–Ω—ã—Ö —Å–µ—Ç—è—Ö

**Information Bottleneck:**
–ú–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–∏:
$$\mathcal{L} = -I(T;Y) + \beta I(X;T)$$

–≥–¥–µ $T$ - —Å–∫—Ä—ã—Ç–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ, $\beta$ - –ø–∞—Ä–∞–º–µ—Ç—Ä —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏–∏.

---

## –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Ç–µ–º—ã

### –ê–ª–≥–æ—Ä–∏—Ç–º–∏—á–µ—Å–∫–∞—è —Ç–µ–æ—Ä–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏

**–ö–æ–ª–º–æ–≥–æ—Ä–æ–≤—Å–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å:**
$$K(x) = \min_{p} \{|p| : U(p) = x\}$$

–≥–¥–µ $U$ - —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –º–∞—à–∏–Ω–∞ –¢—å—é—Ä–∏–Ω–≥–∞.

### –°–∂–∞—Ç–∏–µ –¥–∞–Ω–Ω—ã—Ö

**–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ –∫–æ–¥—ã:**
- –ö–æ–¥ –≠–ª–∏–∞—Å–∞-Œ≥
- –ö–æ–¥ –≠–ª–∏–∞—Å–∞-Œ¥
- –ö–æ–¥ –§–∏–±–æ–Ω–∞—á—á–∏

**–ê–ª–≥–æ—Ä–∏—Ç–º –õ–µ–º–ø–µ–ª—è-–ó–∏–≤–∞:**
```python
def lz77_compress(data, window_size=4096):
    """–°–∂–∞—Ç–∏–µ LZ77"""
    compressed = []
    i = 0
    
    while i < len(data):
        # –ü–æ–∏—Å–∫ —Å–∞–º–æ–≥–æ –¥–ª–∏–Ω–Ω–æ–≥–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –≤ –æ–∫–Ω–µ
        best_match = (0, 0)  # (offset, length)
        
        start = max(0, i - window_size)
        for j in range(start, i):
            length = 0
            while (i + length < len(data) and 
                   j + length < i and 
                   data[j + length] == data[i + length]):
                length += 1
            
            if length > best_match[1]:
                best_match = (i - j, length)
        
        if best_match[1] > 0:
            # –ù–∞–π–¥–µ–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
            compressed.append(('match', best_match[0], best_match[1]))
            i += best_match[1]
        else:
            # –ù–µ—Ç —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
            compressed.append(('literal', data[i]))
            i += 1
    
    return compressed
```

---

## –°–≤—è–∑–∞–Ω–Ω—ã–µ —Ç–µ–º—ã

- [[probability-theory]] - –¢–µ–æ—Ä–∏—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π
- [[cryptography-security]] - –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è
- [[machine-learning-theory]] - –ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ
- [[discrete-mathematics]] - –î–∏—Å–∫—Ä–µ—Ç–Ω–∞—è –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞

---

*–¢–µ–æ—Ä–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ —è–≤–ª—è–µ—Ç—Å—è —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–æ–π –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –ø–µ—Ä–µ–¥–∞—á–∏, —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏. –û–Ω–∞ –Ω–∞—Ö–æ–¥–∏—Ç –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ —Å–∂–∞—Ç–∏–∏ –¥–∞–Ω–Ω—ã—Ö, –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏, –º–∞—à–∏–Ω–Ω–æ–º –æ–±—É—á–µ–Ω–∏–∏ –∏ –º–Ω–æ–≥–∏—Ö –¥—Ä—É–≥–∏—Ö –æ–±–ª–∞—Å—Ç—è—Ö –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω—ã—Ö –Ω–∞—É–∫.* 