	# –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –¥–ª—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–≤

## üéØ –¶–µ–ª—å –∫—É—Ä—Å–∞

–ì–ª—É–±–æ–∫–æ–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –∏ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è.

## üìö –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

1. [–ü—Ä–µ–¥–µ–ª—ã –∏ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ—Å—Ç—å](#–ø—Ä–µ–¥–µ–ª—ã-–∏-–Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ—Å—Ç—å)
2. [–î–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ –∏—Å—á–∏—Å–ª–µ–Ω–∏–µ](#–¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ-–∏—Å—á–∏—Å–ª–µ–Ω–∏–µ)
3. [–ò–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–æ–µ –∏—Å—á–∏—Å–ª–µ–Ω–∏–µ](#–∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–æ–µ-–∏—Å—á–∏—Å–ª–µ–Ω–∏–µ)
4. [–†—è–¥—ã –∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏](#—Ä—è–¥—ã-–∏-–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏)
5. [–ú–Ω–æ–≥–æ–º–µ—Ä–Ω—ã–π –∞–Ω–∞–ª–∏–∑](#–º–Ω–æ–≥–æ–º–µ—Ä–Ω—ã–π-–∞–Ω–∞–ª–∏–∑)
6. [–ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏](#–ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è-–≤-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏)

---

## –ü—Ä–µ–¥–µ–ª—ã –∏ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ—Å—Ç—å

### –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∏ –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–Ω—è—Ç–∏—è

**–ü—Ä–µ–¥–µ–ª —Ñ—É–Ω–∫—Ü–∏–∏**: –ß–∏—Å–ª–æ $L$ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–µ–¥–µ–ª–æ–º —Ñ—É–Ω–∫—Ü–∏–∏ $f(x)$ –ø—Ä–∏ $x \to a$, –µ—Å–ª–∏ –¥–ª—è –ª—é–±–æ–≥–æ $\varepsilon > 0$ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç $\delta > 0$ —Ç–∞–∫–æ–µ, —á—Ç–æ:

$$\forall x: 0 < |x - a| < \delta \Rightarrow |f(x) - L| < \varepsilon$$

–û–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ: $\lim_{x \to a} f(x) = L$

**–í–∞–∂–Ω—ã–µ –ø—Ä–µ–¥–µ–ª—ã**:
- $\lim_{x \to 0} \frac{\sin x}{x} = 1$
- $\lim_{x \to \infty} \left(1 + \frac{1}{x}\right)^x = e$
- $\lim_{x \to 0} \frac{e^x - 1}{x} = 1$
- $\lim_{x \to 0} \frac{\ln(1 + x)}{x} = 1$

**–¢–µ–æ—Ä–µ–º—ã –æ –ø—Ä–µ–¥–µ–ª–∞—Ö**:
$$\lim_{x \to a} [f(x) \pm g(x)] = \lim_{x \to a} f(x) \pm \lim_{x \to a} g(x)$$
$$\lim_{x \to a} [f(x) \cdot g(x)] = \lim_{x \to a} f(x) \cdot \lim_{x \to a} g(x)$$
$$\lim_{x \to a} \frac{f(x)}{g(x)} = \frac{\lim_{x \to a} f(x)}{\lim_{x \to a} g(x)}, \quad \text{–µ—Å–ª–∏ } \lim_{x \to a} g(x) \neq 0$$

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize_scalar

def visualize_limit(f, x_approach, epsilon=0.01):
    """–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–µ–¥–µ–ª–∞ —Ñ—É–Ω–∫—Ü–∏–∏"""
    x_values = np.linspace(x_approach - 1, x_approach + 1, 1000)
    y_values = [f(x) for x in x_values if abs(x - x_approach) > epsilon]
    
    plt.figure(figsize=(10, 6))
    plt.plot(x_values[:-1], y_values, 'b-', linewidth=2)
    plt.axvline(x=x_approach, color='r', linestyle='--', alpha=0.7)
    plt.title(f'–ü—Ä–µ–¥–µ–ª —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–∏ x ‚Üí {x_approach}')
    plt.grid(True, alpha=0.3)
    plt.show()

# –ü—Ä–∏–º–µ—Ä: –ø—Ä–µ–¥–µ–ª sin(x)/x –ø—Ä–∏ x ‚Üí 0
# –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏: lim(x‚Üí0) sin(x)/x = 1
def sinc_limit(x):
    if abs(x) < 1e-10:
        return 1  # –ü—Ä–µ–¥–µ–ª —Ä–∞–≤–µ–Ω 1
    return np.sin(x) / x

# –ß–∏—Å–ª–µ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –ø—Ä–µ–¥–µ–ª–∞
def numerical_limit(f, x_approach, h=1e-6):
    """–ß–∏—Å–ª–µ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –ø—Ä–µ–¥–µ–ª–∞"""
    left_limit = f(x_approach - h)
    right_limit = f(x_approach + h)
    return (left_limit + right_limit) / 2

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
print(f"–ü—Ä–µ–¥–µ–ª sin(x)/x –ø—Ä–∏ x‚Üí0: {numerical_limit(sinc_limit, 0)}")
```

### –ù–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ—Å—Ç—å –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–∞—Ö

**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ—Å—Ç–∏**: –§—É–Ω–∫—Ü–∏—è $f(x)$ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–∞ –≤ —Ç–æ—á–∫–µ $a$, –µ—Å–ª–∏:
$$\lim_{x \to a} f(x) = f(a)$$

**–í–∏–¥—ã —Ä–∞–∑—Ä—ã–≤–æ–≤**:
1. **–£—Å—Ç—Ä–∞–Ω–∏–º—ã–π —Ä–∞–∑—Ä—ã–≤**: $\lim_{x \to a} f(x)$ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –Ω–æ $\lim_{x \to a} f(x) \neq f(a)$
2. **–†–∞–∑—Ä—ã–≤ –ø–µ—Ä–≤–æ–≥–æ —Ä–æ–¥–∞**: $\lim_{x \to a^-} f(x) \neq \lim_{x \to a^+} f(x)$ (—Å–∫–∞—á–æ–∫)
3. **–†–∞–∑—Ä—ã–≤ –≤—Ç–æ—Ä–æ–≥–æ —Ä–æ–¥–∞**: –æ–¥–∏–Ω –∏–∑ –æ–¥–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö –ø—Ä–µ–¥–µ–ª–æ–≤ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç

```python
class ContinuousFunction:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–º–∏ —Ñ—É–Ω–∫—Ü–∏—è–º–∏"""
    
    def __init__(self, func, domain):
        self.func = func
        self.domain = domain
    
    def is_continuous_at(self, x, tolerance=1e-6):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ—Å—Ç–∏ –≤ —Ç–æ—á–∫–µ"""
        if x not in self.domain:
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–µ–¥–µ–ª—ã —Å–ª–µ–≤–∞ –∏ —Å–ø—Ä–∞–≤–∞
        h = tolerance / 10
        left_limit = self.func(x - h)
        right_limit = self.func(x + h)
        function_value = self.func(x)
        
        return (abs(left_limit - function_value) < tolerance and 
                abs(right_limit - function_value) < tolerance)
    
    def find_discontinuities(self, num_points=1000):
        """–ü–æ–∏—Å–∫ —Ä–∞–∑—Ä—ã–≤–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏"""
        discontinuities = []
        
        for x in np.linspace(self.domain[0], self.domain[1], num_points):
            if not self.is_continuous_at(x):
                discontinuities.append(x)
        
        return discontinuities

# –ü—Ä–∏–º–µ—Ä: —Ñ—É–Ω–∫—Ü–∏—è —Å —Ä–∞–∑—Ä—ã–≤–æ–º
def step_function(x):
    return 1 if x >= 0 else -1

step_func = ContinuousFunction(step_function, [-2, 2])
print(f"–†–∞–∑—Ä—ã–≤—ã: {step_func.find_discontinuities()}")
```

---

## –î–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ –∏—Å—á–∏—Å–ª–µ–Ω–∏–µ

### –ü—Ä–æ–∏–∑–≤–æ–¥–Ω—ã–µ –∏ –∏—Ö –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ

**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–æ–π**: –ü—Ä–æ–∏–∑–≤–æ–¥–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ $f(x)$ –≤ —Ç–æ—á–∫–µ $x$ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–µ–¥–µ–ª:
$$f'(x) = \lim_{h \to 0} \frac{f(x + h) - f(x)}{h}$$

**–û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–æ–≤–∞–Ω–∏—è**:
- $(c)' = 0$ (–∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞)
- $(x^n)' = nx^{n-1}$ (—Å—Ç–µ–ø–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è)
- $(e^x)' = e^x$ (—ç–∫—Å–ø–æ–Ω–µ–Ω—Ç–∞)
- $(\ln x)' = \frac{1}{x}$ (–Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã–π –ª–æ–≥–∞—Ä–∏—Ñ–º)
- $(\sin x)' = \cos x$ (—Å–∏–Ω—É—Å)
- $(\cos x)' = -\sin x$ (–∫–æ—Å–∏–Ω—É—Å)

**–ü—Ä–∞–≤–∏–ª–∞ –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–æ–≤–∞–Ω–∏—è**:
- $(f \pm g)' = f' \pm g'$ (—Å—É–º–º–∞/—Ä–∞–∑–Ω–æ—Å—Ç—å)
- $(fg)' = f'g + fg'$ (–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ)
- $\left(\frac{f}{g}\right)' = \frac{f'g - fg'}{g^2}$ (—á–∞—Å—Ç–Ω–æ–µ)
- $(f(g(x)))' = f'(g(x)) \cdot g'(x)$ (—Ü–µ–ø–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ)

```python
import sympy as sp
from scipy.misc import derivative

def automatic_differentiation(f, x, h=1e-8):
    """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ"""
    return (f(x + h) - f(x - h)) / (2 * h)

def gradient_descent(f, df, x_start, learning_rate=0.01, max_iter=1000):
    """–ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Å–ø—É—Å–∫ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏"""
    x = x_start
    history = [x]
    
    for i in range(max_iter):
        grad = df(x)
        x_new = x - learning_rate * grad
        
        if abs(x_new - x) < 1e-6:
            break
        
        x = x_new
        history.append(x)
    
    return x, history

# –ü—Ä–∏–º–µ—Ä: –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ f(x) = x¬≤ + 2x + 1
# f'(x) = 2x + 2
def f(x):
    return x**2 + 2*x + 1

def df(x):
    return 2*x + 2

minimum, path = gradient_descent(f, df, x_start=5)
print(f"–ú–∏–Ω–∏–º—É–º —Ñ—É–Ω–∫—Ü–∏–∏: x = {minimum}, f(x) = {f(minimum)}")
```

### –ú–Ω–æ–≥–æ–º–µ—Ä–Ω—ã–µ –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã–µ

**–ß–∞—Å—Ç–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è**: –î–ª—è —Ñ—É–Ω–∫—Ü–∏–∏ $f(x, y)$ —á–∞—Å—Ç–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è –ø–æ $x$:
$$\frac{\partial f}{\partial x} = \lim_{h \to 0} \frac{f(x + h, y) - f(x, y)}{h}$$

**–ì—Ä–∞–¥–∏–µ–Ω—Ç**: –í–µ–∫—Ç–æ—Ä —á–∞—Å—Ç–Ω—ã—Ö –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–∏ $f(x_1, x_2, \ldots, x_n)$:
$$\nabla f = \left(\frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2}, \ldots, \frac{\partial f}{\partial x_n}\right)$$

**–ú–∞—Ç—Ä–∏—Ü–∞ –ì–µ—Å—Å–µ**: –ú–∞—Ç—Ä–∏—Ü–∞ –≤—Ç–æ—Ä—ã—Ö —á–∞—Å—Ç–Ω—ã—Ö –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã—Ö:
$$H_f = \begin{pmatrix}
\frac{\partial^2 f}{\partial x_1^2} & \frac{\partial^2 f}{\partial x_1 \partial x_2} & \cdots \\
\frac{\partial^2 f}{\partial x_2 \partial x_1} & \frac{\partial^2 f}{\partial x_2^2} & \cdots \\
\vdots & \vdots & \ddots
\end{pmatrix}$$

**–£—Å–ª–æ–≤–∏—è —ç–∫—Å—Ç—Ä–µ–º—É–º–∞**:
- **–ù–µ–æ–±—Ö–æ–¥–∏–º–æ–µ —É—Å–ª–æ–≤–∏–µ**: $\nabla f = 0$
- **–î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–µ —É—Å–ª–æ–≤–∏–µ**: $H_f$ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ (–º–∏–Ω–∏–º—É–º) –∏–ª–∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ (–º–∞–∫—Å–∏–º—É–º)

```python
import numpy as np
from scipy.optimize import minimize

def partial_derivative(f, x, var_index, h=1e-8):
    """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ —á–∞—Å—Ç–Ω–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–æ–π"""
    x_plus = x.copy()
    x_minus = x.copy()
    
    x_plus[var_index] += h
    x_minus[var_index] -= h
    
    return (f(x_plus) - f(x_minus)) / (2 * h)

def gradient(f, x, h=1e-8):
    """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞"""
    return np.array([partial_derivative(f, x, i, h) for i in range(len(x))])

def hessian(f, x, h=1e-6):
    """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –ì–µ—Å—Å–µ"""
    n = len(x)
    H = np.zeros((n, n))
    
    for i in range(n):
        for j in range(n):
            if i == j:
                # –í—Ç–æ—Ä–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è –ø–æ –æ–¥–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
                H[i, j] = (f(x + h*np.eye(n)[i]) - 2*f(x) + f(x - h*np.eye(n)[i])) / h**2
            else:
                # –°–º–µ—à–∞–Ω–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è
                x_pp = x + h*np.eye(n)[i] + h*np.eye(n)[j]
                x_pm = x + h*np.eye(n)[i] - h*np.eye(n)[j]
                x_mp = x - h*np.eye(n)[i] + h*np.eye(n)[j]
                x_mm = x - h*np.eye(n)[i] - h*np.eye(n)[j]
                
                H[i, j] = (f(x_pp) - f(x_pm) - f(x_mp) + f(x_mm)) / (4 * h**2)
    
    return H

# –ü—Ä–∏–º–µ—Ä: —Ñ—É–Ω–∫—Ü–∏—è –¥–≤—É—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
def f_2d(x):
    return x[0]**2 + x[1]**2 + 2*x[0]*x[1] + 3*x[0] + 4*x[1]

x_point = np.array([1.0, 2.0])
grad = gradient(f_2d, x_point)
H = hessian(f_2d, x_point)

print(f"–ì—Ä–∞–¥–∏–µ–Ω—Ç –≤ —Ç–æ—á–∫–µ {x_point}: {grad}")
print(f"–ú–∞—Ç—Ä–∏—Ü–∞ –ì–µ—Å—Å–µ:\n{H}")
```

---

## –ò–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–æ–µ –∏—Å—á–∏—Å–ª–µ–Ω–∏–µ

### –û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–Ω—è—Ç–∏—è

**–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–≥—Ä–∞–ª**: –ú–Ω–æ–∂–µ—Å—Ç–≤–æ –≤—Å–µ—Ö –ø–µ—Ä–≤–æ–æ–±—Ä–∞–∑–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–∏ $f(x)$:
$$\int f(x) dx = F(x) + C, \quad \text{–≥–¥–µ } F'(x) = f(x)$$

**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–≥—Ä–∞–ª**: –ü—Ä–µ–¥–µ–ª –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω—ã—Ö —Å—É–º–º –†–∏–º–∞–Ω–∞:
$$\int_a^b f(x) dx = \lim_{n \to \infty} \sum_{i=1}^n f(x_i) \Delta x$$

**–û—Å–Ω–æ–≤–Ω–∞—è —Ç–µ–æ—Ä–µ–º–∞ –∏—Å—á–∏—Å–ª–µ–Ω–∏—è**:
$$\int_a^b f(x) dx = F(b) - F(a), \quad \text{–≥–¥–µ } F'(x) = f(x)$$

**–û—Å–Ω–æ–≤–Ω—ã–µ –∏–Ω—Ç–µ–≥—Ä–∞–ª—ã**:
- $\int x^n dx = \frac{x^{n+1}}{n+1} + C$ (–¥–ª—è $n \neq -1$)
- $\int \frac{1}{x} dx = \ln|x| + C$
- $\int e^x dx = e^x + C$
- $\int \sin x dx = -\cos x + C$
- $\int \cos x dx = \sin x + C$

**–ú–µ—Ç–æ–¥—ã –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏—è**:
- **–ü–æ —á–∞—Å—Ç—è–º**: $\int u dv = uv - \int v du$
- **–ó–∞–º–µ–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π**: $\int f(g(x))g'(x) dx = \int f(u) du$, –≥–¥–µ $u = g(x)$

### –ß–∏—Å–ª–µ–Ω–Ω–æ–µ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ

```python
import numpy as np
from scipy.integrate import quad, dblquad

def trapezoidal_rule(f, a, b, n=100):
    """–ü—Ä–∞–≤–∏–ª–æ —Ç—Ä–∞–ø–µ—Ü–∏–π"""
    h = (b - a) / n
    x = np.linspace(a, b, n + 1)
    y = f(x)
    
    return h * (y[0]/2 + np.sum(y[1:-1]) + y[-1]/2)

def simpson_rule(f, a, b, n=100):
    """–ü—Ä–∞–≤–∏–ª–æ –°–∏–º–ø—Å–æ–Ω–∞"""
    if n % 2 == 1:
        n += 1  # –î–æ–ª–∂–Ω–æ –±—ã—Ç—å —á–µ—Ç–Ω—ã–º
    
    h = (b - a) / n
    x = np.linspace(a, b, n + 1)
    y = f(x)
    
    return h/3 * (y[0] + 4*np.sum(y[1:-1:2]) + 2*np.sum(y[2:-1:2]) + y[-1])

def monte_carlo_integration(f, a, b, n=100000):
    """–ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –º–µ—Ç–æ–¥–æ–º –ú–æ–Ω—Ç–µ-–ö–∞—Ä–ª–æ"""
    x_random = np.random.uniform(a, b, n)
    y_values = f(x_random)
    
    return (b - a) * np.mean(y_values)

# –ü—Ä–∏–º–µ—Ä: –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ e^(-x^2)
def gaussian(x):
    return np.exp(-x**2)

# –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–≤
a, b = -2, 2
true_value, _ = quad(gaussian, a, b)
trap_value = trapezoidal_rule(gaussian, a, b)
simp_value = simpson_rule(gaussian, a, b)
mc_value = monte_carlo_integration(gaussian, a, b)

print(f"–¢–æ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {true_value:.6f}")
print(f"–¢—Ä–∞–ø–µ—Ü–∏–∏: {trap_value:.6f}")
print(f"–°–∏–º–ø—Å–æ–Ω: {simp_value:.6f}")
print(f"–ú–æ–Ω—Ç–µ-–ö–∞—Ä–ª–æ: {mc_value:.6f}")
```

### –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ –º–∞—à–∏–Ω–Ω–æ–º –æ–±—É—á–µ–Ω–∏–∏

```python
def gaussian_kernel(x, mu, sigma):
    """–ì–∞—É—Å—Å–æ–≤–æ —è–¥—Ä–æ –¥–ª—è SVM"""
    return np.exp(-(x - mu)**2 / (2 * sigma**2))

def integrate_gaussian_mixture(components, x_range):
    """–ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–º–µ—Å–∏ –≥–∞—É—Å—Å–æ–≤—ã—Ö —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π"""
    def mixture(x):
        return sum(w * gaussian_kernel(x, mu, sigma) 
                  for w, mu, sigma in components)
    
    integral, _ = quad(mixture, x_range[0], x_range[1])
    return integral

# –ü—Ä–∏–º–µ—Ä: —Å–º–µ—Å—å –¥–≤—É—Ö –≥–∞—É—Å—Å–æ–≤—ã—Ö —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π
components = [
    (0.3, 0, 1),    # –≤–µ—Å=0.3, Œº=0, œÉ=1
    (0.7, 2, 0.5)   # –≤–µ—Å=0.7, Œº=2, œÉ=0.5
]

total_prob = integrate_gaussian_mixture(components, [-5, 5])
print(f"–ü–æ–ª–Ω–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å: {total_prob}")
```

---

## –†—è–¥—ã –∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

### –°—Ç–µ–ø–µ–Ω–Ω—ã–µ —Ä—è–¥—ã

```python
import numpy as np
from scipy.special import factorial

def taylor_series(f, x0, n_terms=10):
    """–†–∞–∑–ª–æ–∂–µ–Ω–∏–µ –≤ —Ä—è–¥ –¢–µ–π–ª–æ—Ä–∞"""
    def get_derivative(f, x, n, h=1e-8):
        """–ß–∏—Å–ª–µ–Ω–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è n-–≥–æ –ø–æ—Ä—è–¥–∫–∞"""
        if n == 0:
            return f(x)
        elif n == 1:
            return (f(x + h) - f(x - h)) / (2 * h)
        else:
            # –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤—ã—Å—à–∏—Ö –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã—Ö
            return (get_derivative(f, x + h, n - 1, h) - 
                   get_derivative(f, x - h, n - 1, h)) / (2 * h)
    
    def taylor_approximation(x):
        result = 0
        for n in range(n_terms):
            coeff = get_derivative(f, x0, n) / factorial(n)
            result += coeff * (x - x0)**n
        return result
    
    return taylor_approximation

# –ü—Ä–∏–º–µ—Ä: —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ exp(x) –≤ —Ä—è–¥ –¢–µ–π–ª–æ—Ä–∞
def exp_func(x):
    return np.exp(x)

exp_taylor = taylor_series(exp_func, x0=0, n_terms=15)

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ—á–Ω–æ—Å—Ç–∏
x_test = 1.0
exact = np.exp(x_test)
approx = exp_taylor(x_test)

print(f"–¢–æ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ exp({x_test}): {exact}")
print(f"–ü—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ –¢–µ–π–ª–æ—Ä–∞: {approx}")
print(f"–û—à–∏–±–∫–∞: {abs(exact - approx)}")
```

### –†—è–¥—ã –§—É—Ä—å–µ

```python
def fourier_series(f, period, n_terms=10):
    """–†–∞–∑–ª–æ–∂–µ–Ω–∏–µ –≤ —Ä—è–¥ –§—É—Ä—å–µ"""
    T = period
    
    # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã
    def a0():
        return 2/T * quad(f, 0, T)[0]
    
    def an(n):
        return 2/T * quad(lambda x: f(x) * np.cos(2*np.pi*n*x/T), 0, T)[0]
    
    def bn(n):
        return 2/T * quad(lambda x: f(x) * np.sin(2*np.pi*n*x/T), 0, T)[0]
    
    # –ê–ø–ø—Ä–æ–∫—Å–∏–º–∞—Ü–∏—è
    def fourier_approx(x):
        result = a0() / 2
        for n in range(1, n_terms + 1):
            result += an(n) * np.cos(2*np.pi*n*x/T)
            result += bn(n) * np.sin(2*np.pi*n*x/T)
        return result
    
    return fourier_approx

# –ü—Ä–∏–º–µ—Ä: —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
def square_wave(x):
    return 1 if x % 2 < 1 else -1

square_fourier = fourier_series(square_wave, period=2, n_terms=20)

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
x_values = np.linspace(0, 4, 1000)
original = [square_wave(x) for x in x_values]
approximation = [square_fourier(x) for x in x_values]

plt.figure(figsize=(12, 6))
plt.plot(x_values, original, 'b-', label='–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è', linewidth=2)
plt.plot(x_values, approximation, 'r--', label='–†—è–¥ –§—É—Ä—å–µ', linewidth=2)
plt.legend()
plt.grid(True)
plt.title('–†–∞–∑–ª–æ–∂–µ–Ω–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –≤ —Ä—è–¥ –§—É—Ä—å–µ')
plt.show()
```

---

## –ú–Ω–æ–≥–æ–º–µ—Ä–Ω—ã–π –∞–Ω–∞–ª–∏–∑

### –í–µ–∫—Ç–æ—Ä–Ω—ã–π –∞–Ω–∞–ª–∏–∑

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

class VectorField:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≤–µ–∫—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ª—è–º–∏"""
    
    def __init__(self, field_func):
        self.field_func = field_func
    
    def divergence(self, point, h=1e-6):
        """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–∏"""
        x, y, z = point
        
        # –ß–∞—Å—Ç–Ω—ã–µ –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
        fx_x = (self.field_func([x + h, y, z])[0] - 
               self.field_func([x - h, y, z])[0]) / (2 * h)
        fy_y = (self.field_func([x, y + h, z])[1] - 
               self.field_func([x, y - h, z])[1]) / (2 * h)
        fz_z = (self.field_func([x, y, z + h])[2] - 
               self.field_func([x, y, z - h])[2]) / (2 * h)
        
        return fx_x + fy_y + fz_z
    
    def curl(self, point, h=1e-6):
        """–í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ä–æ—Ç–æ—Ä–∞"""
        x, y, z = point
        
        # –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Ä–æ—Ç–æ—Ä–∞
        curl_x = ((self.field_func([x, y, z + h])[1] - 
                  self.field_func([x, y, z - h])[1]) / (2 * h) -
                 (self.field_func([x, y + h, z])[2] - 
                  self.field_func([x, y - h, z])[2]) / (2 * h))
        
        curl_y = ((self.field_func([x + h, y, z])[2] - 
                  self.field_func([x - h, y, z])[2]) / (2 * h) -
                 (self.field_func([x, y, z + h])[0] - 
                  self.field_func([x, y, z - h])[0]) / (2 * h))
        
        curl_z = ((self.field_func([x, y + h, z])[0] - 
                  self.field_func([x, y - h, z])[0]) / (2 * h) -
                 (self.field_func([x + h, y, z])[1] - 
                  self.field_func([x - h, y, z])[1]) / (2 * h))
        
        return np.array([curl_x, curl_y, curl_z])

# –ü—Ä–∏–º–µ—Ä: —ç–ª–µ–∫—Ç—Ä–æ—Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–æ–ª–µ
def electric_field(r):
    x, y, z = r
    r_mag = np.sqrt(x**2 + y**2 + z**2)
    if r_mag == 0:
        return np.array([0, 0, 0])
    
    # –ü–æ–ª–µ —Ç–æ—á–µ—á–Ω–æ–≥–æ –∑–∞—Ä—è–¥–∞
    k = 1  # –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞
    return k * np.array([x, y, z]) / r_mag**3

efield = VectorField(electric_field)

# –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—é –≤ —Ä–∞–∑–Ω—ã—Ö —Ç–æ—á–∫–∞—Ö
test_points = [[1, 0, 0], [0, 1, 0], [1, 1, 1]]
for point in test_points:
    div = efield.divergence(point)
    curl = efield.curl(point)
    print(f"–¢–æ—á–∫–∞ {point}: div = {div:.6f}, curl = {curl}")
```

---

## –ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏

### –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤

```python
from scipy.optimize import minimize
import numpy as np

def gradient_based_optimization():
    """–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞"""
    
    # –§—É–Ω–∫—Ü–∏—è –†–æ–∑–µ–Ω–±—Ä–æ–∫–∞ (—Å–ª–æ–∂–Ω–∞—è –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏)
    def rosenbrock(x):
        return sum(100 * (x[i+1] - x[i]**2)**2 + (1 - x[i])**2 
                  for i in range(len(x) - 1))
    
    def rosenbrock_gradient(x):
        grad = np.zeros_like(x)
        grad[0] = -400 * x[0] * (x[1] - x[0]**2) - 2 * (1 - x[0])
        
        for i in range(1, len(x) - 1):
            grad[i] = (200 * (x[i] - x[i-1]**2) - 
                      400 * x[i] * (x[i+1] - x[i]**2) - 
                      2 * (1 - x[i]))
        
        grad[-1] = 200 * (x[-1] - x[-2]**2)
        return grad
    
    # –†–∞–∑–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
    methods = ['BFGS', 'L-BFGS-B', 'CG', 'Newton-CG']
    x0 = np.array([0, 0])
    
    for method in methods:
        if method == 'Newton-CG':
            result = minimize(rosenbrock, x0, method=method, 
                            jac=rosenbrock_gradient)
        else:
            result = minimize(rosenbrock, x0, method=method)
        
        print(f"{method}: x = {result.x}, f(x) = {result.fun}, "
              f"iterations = {result.nit}")

gradient_based_optimization()
```

### –ê–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤

```python
import time
import numpy as np
import matplotlib.pyplot as plt

def complexity_analysis():
    """–≠–º–ø–∏—Ä–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤"""
    
    def bubble_sort(arr):
        n = len(arr)
        for i in range(n):
            for j in range(0, n - i - 1):
                if arr[j] > arr[j + 1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
        return arr
    
    def merge_sort(arr):
        if len(arr) <= 1:
            return arr
        
        mid = len(arr) // 2
        left = merge_sort(arr[:mid])
        right = merge_sort(arr[mid:])
        
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    # –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ä–∞–∑–º–µ—Ä–∞—Ö
    sizes = [100, 200, 500, 1000, 2000]
    bubble_times = []
    merge_times = []
    
    for size in sizes:
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        data = np.random.randint(0, 1000, size).tolist()
        
        # –¢–µ—Å—Ç–∏—Ä—É–µ–º bubble sort
        start = time.time()
        bubble_sort(data.copy())
        bubble_times.append(time.time() - start)
        
        # –¢–µ—Å—Ç–∏—Ä—É–µ–º merge sort
        start = time.time()
        merge_sort(data.copy())
        merge_times.append(time.time() - start)
    
    # –ê–Ω–∞–ª–∏–∑ —Ä–æ—Å—Ç–∞ –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    plt.figure(figsize=(10, 6))
    plt.plot(sizes, bubble_times, 'ro-', label='Bubble Sort O(n¬≤)')
    plt.plot(sizes, merge_times, 'bo-', label='Merge Sort O(n log n)')
    plt.xlabel('–†–∞–∑–º–µ—Ä –º–∞—Å—Å–∏–≤–∞')
    plt.ylabel('–í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (—Å–µ–∫)')
    plt.legend()
    plt.grid(True)
    plt.title('–°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏')
    plt.show()
    
    # –¢–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏–µ vs —ç–º–ø–∏—Ä–∏—á–µ—Å–∫–∏–µ –æ—Ü–µ–Ω–∫–∏
    theoretical_bubble = [n**2 for n in sizes]
    theoretical_merge = [n * np.log(n) for n in sizes]
    
    # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
    bubble_normalized = np.array(bubble_times) / max(bubble_times)
    merge_normalized = np.array(merge_times) / max(merge_times)
    theoretical_bubble_norm = np.array(theoretical_bubble) / max(theoretical_bubble)
    theoretical_merge_norm = np.array(theoretical_merge) / max(theoretical_merge)
    
    print("–ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è —ç–º–ø–∏—Ä–∏—á–µ—Å–∫–∏—Ö –∏ —Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏—Ö –æ—Ü–µ–Ω–æ–∫:")
    print(f"Bubble Sort: {np.corrcoef(bubble_normalized, theoretical_bubble_norm)[0,1]:.3f}")
    print(f"Merge Sort: {np.corrcoef(merge_normalized, theoretical_merge_norm)[0,1]:.3f}")

complexity_analysis()
```

## üéØ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞–Ω–∏—è

### –ó–∞–¥–∞–Ω–∏–µ 1: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–µ–π—Ä–æ–Ω–Ω–æ–π —Å–µ—Ç–∏
–†–µ–∞–ª–∏–∑—É–π—Ç–µ backpropagation –∏—Å–ø–æ–ª—å–∑—É—è –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã–µ –∏ —Ü–µ–ø–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ.

### –ó–∞–¥–∞–Ω–∏–µ 2: –ß–∏—Å–ª–µ–Ω–Ω–æ–µ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ
–°–æ–∑–¥–∞–π—Ç–µ —Å–∏—Å—Ç–µ–º—É –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –ø–ª–æ—â–∞–¥–∏ –ø–æ–¥ –∫—Ä–∏–≤–æ–π ROC.

### –ó–∞–¥–∞–Ω–∏–µ 3: –†—è–¥—ã –≤ –∞–Ω–∞–ª–∏–∑–µ –¥–∞–Ω–Ω—ã—Ö
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä—è–¥—ã –§—É—Ä—å–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö.

### –ó–∞–¥–∞–Ω–∏–µ 4: –ú–Ω–æ–≥–æ–º–µ—Ä–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –∞–ª–≥–æ—Ä–∏—Ç–º –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–≥–æ —Å–ø—É—Å–∫–∞ –¥–ª—è –ª–∏–Ω–µ–π–Ω–æ–π —Ä–µ–≥—Ä–µ—Å—Å–∏–∏.

---

## üîó –°–≤—è–∑–∞–Ω–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã

- [–õ–∏–Ω–µ–π–Ω–∞—è –∞–ª–≥–µ–±—Ä–∞](./linear-algebra.md)
- [–ß–∏—Å–ª–µ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã](./numerical-methods.md)
- [–ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ](../algorithms-data-structures/machine-learning-fundamentals.md)
- [–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è](./optimization.md) 