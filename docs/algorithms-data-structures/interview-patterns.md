# –ü–∞—Ç—Ç–µ—Ä–Ω—ã —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á

> **–û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è —É—Å–ø–µ—à–Ω–æ–≥–æ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –∏–Ω—Ç–µ—Ä–≤—å—é**
>
> –û—Ç Two Pointers –¥–æ Backtracking —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –ø—Ä–∏–º–µ—Ä–∞–º–∏ –∑–∞–¥–∞—á

## üéØ –ó–∞—á–µ–º –Ω—É–∂–Ω—ã –ø–∞—Ç—Ç–µ—Ä–Ω—ã?

**–ü–∞—Ç—Ç–µ—Ä–Ω—ã –ø–æ–º–æ–≥–∞—é—Ç:**
- üß† –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å —Ç–∏–ø—ã –∑–∞–¥–∞—á –∑–∞ —Å–µ–∫—É–Ω–¥—ã
- ‚ö° –ë—ã—Å—Ç—Ä–æ –Ω–∞—Ö–æ–¥–∏—Ç—å —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è
- üîÑ –ü—Ä–∏–º–µ–Ω—è—Ç—å –∑–Ω–∞–∫–æ–º—ã–µ –ø–æ–¥—Ö–æ–¥—ã –∫ –Ω–æ–≤—ã–º –∑–∞–¥–∞—á–∞–º
- üìù –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ —Ä–µ—à–∞—Ç—å –∑–∞–¥–∞—á–∏ –Ω–∞ –∏–Ω—Ç–µ—Ä–≤—å—é

---

## üëâ Two Pointers (–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è)

### –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
- –ú–∞—Å—Å–∏–≤/—Å—Ç—Ä–æ–∫–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã
- –ò—â–µ–º –ø–∞—Ä—É —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º —É—Å–ª–æ–≤–∏–µ–º
- –ù—É–∂–Ω–æ –Ω–∞–π—Ç–∏ –ø–æ–¥–º–∞—Å—Å–∏–≤/–ø–æ–¥—Å—Ç—Ä–æ–∫—É

### –®–∞–±–ª–æ–Ω —Ä–µ—à–µ–Ω–∏—è

```python
def two_pointers_template(arr):
    """
    –ë–∞–∑–æ–≤—ã–π —à–∞–±–ª–æ–Ω –¥–ª—è –¥–≤—É—Ö —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
    """
    left = 0
    right = len(arr) - 1
    
    while left < right:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏–µ
        if condition_met(arr[left], arr[right]):
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –Ω–∞–π–¥–µ–Ω–Ω—É—é –ø–∞—Ä—É
            process_pair(arr[left], arr[right])
            left += 1
            right -= 1
        elif need_larger_sum(arr[left], arr[right]):
            left += 1  # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–µ–≤—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å
        else:
            right -= 1  # –£–º–µ–Ω—å—à–∞–µ–º –ø—Ä–∞–≤—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å
    
    return result
```

### –ü—Ä–∏–º–µ—Ä 1: Two Sum –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ

```go
// ==================== TWO SUM –í –û–¢–°–û–†–¢–ò–†–û–í–ê–ù–ù–û–ú –ú–ê–°–°–ò–í–ï ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
func twoSum(numbers []int, target int) []int {
    left := 0
    right := len(numbers) - 1
    
    for left < right {
        currentSum := numbers[left] + numbers[right]
        
        if currentSum == target {
            // –ù–∞–π–¥–µ–Ω–∞ –ø–∞—Ä–∞! –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã (1-based)
            return []int{left + 1, right + 1}
        } else if currentSum < target {
            // –ù—É–∂–Ω–∞ –±–æ–ª—å—à–∞—è —Å—É–º–º–∞ - –¥–≤–∏–≥–∞–µ–º –ª–µ–≤—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å
            left++
        } else {
            // –ù—É–∂–Ω–∞ –º–µ–Ω—å—à–∞—è —Å—É–º–º–∞ - –¥–≤–∏–≥–∞–µ–º –ø—Ä–∞–≤—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å
            right--
        }
    }
    
    return []int{}  // –ù–µ –Ω–∞–π–¥–µ–Ω–æ
}
```

### –ü—Ä–∏–º–µ—Ä 2: –£–¥–∞–ª–µ–Ω–∏–µ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤

```python
def remove_duplicates(arr):
    """
    –£–¥–∞–ª–µ–Ω–∏–µ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ –∏–∑ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
    """
    if not arr:
        return 0
    
    # –î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è: slow - –¥–ª—è –∑–∞–ø–∏—Å–∏, fast - –¥–ª—è —á—Ç–µ–Ω–∏—è
    slow = 0
    
    for fast in range(1, len(arr)):
        # –ï—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç—ã —Ä–∞–∑–Ω—ã–µ, –∑–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ –ø–æ–∑–∏—Ü–∏—é slow
        if arr[fast] != arr[slow]:
            slow += 1
            arr[slow] = arr[fast]
    
    return slow + 1  # –ù–æ–≤–∞—è –¥–ª–∏–Ω–∞ –º–∞—Å—Å–∏–≤–∞
```

---

## üîÑ Sliding Window (–°–∫–æ–ª—å–∑—è—â–µ–µ –æ–∫–Ω–æ)

### –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
- –ù—É–∂–Ω–æ –Ω–∞–π—Ç–∏ –ø–æ–¥–º–∞—Å—Å–∏–≤/–ø–æ–¥—Å—Ç—Ä–æ–∫—É —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã
- –ú–∞–∫—Å–∏–º—É–º/–º–∏–Ω–∏–º—É–º –≤ –ø–æ–¥–º–∞—Å—Å–∏–≤–µ
- –ü–æ–¥–º–∞—Å—Å–∏–≤ —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º —É—Å–ª–æ–≤–∏–µ–º

### –®–∞–±–ª–æ–Ω —Ä–µ—à–µ–Ω–∏—è

```python
def sliding_window_template(arr, k):
    """
    –ë–∞–∑–æ–≤—ã–π —à–∞–±–ª–æ–Ω —Å–∫–æ–ª—å–∑—è—â–µ–≥–æ –æ–∫–Ω–∞
    """
    left = 0
    window_sum = 0
    result = []
    
    for right in range(len(arr)):
        # –†–∞—Å—à–∏—Ä—è–µ–º –æ–∫–Ω–æ
        window_sum += arr[right]
        
        # –ï—Å–ª–∏ –æ–∫–Ω–æ –¥–æ—Å—Ç–∏–≥–ª–æ –Ω—É–∂–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
        while window_size_condition(left, right, k):
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–µ–∫—É—â–µ–µ –æ–∫–Ω–æ
            process_window(arr, left, right, window_sum)
            
            # –°–∂–∏–º–∞–µ–º –æ–∫–Ω–æ
            window_sum -= arr[left]
            left += 1
    
    return result
```

### –ü—Ä–∏–º–µ—Ä 1: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–¥–º–∞—Å—Å–∏–≤–∞ –¥–ª–∏–Ω—ã k

```go
// ==================== –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–ê–Ø –°–£–ú–ú–ê –ü–û–î–ú–ê–°–°–ò–í–ê –î–õ–ò–ù–´ K ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
func maxSumSubarray(arr []int, k int) int {
    if len(arr) < k {
        return 0
    }
    
    // –í—ã—á–∏—Å–ª—è–µ–º —Å—É–º–º—É –ø–µ—Ä–≤–æ–≥–æ –æ–∫–Ω–∞
    windowSum := 0
    for i := 0; i < k; i++ {
        windowSum += arr[i]
    }
    
    maxSum := windowSum
    
    // –°–∫–æ–ª—å–∑–∏–º –æ–∫–Ω–æ –ø–æ –æ—Å—Ç–∞–≤—à–∏–º—Å—è —ç–ª–µ–º–µ–Ω—Ç–∞–º
    for i := k; i < len(arr); i++ {
        // –£–±–∏—Ä–∞–µ–º –ª–µ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç, –¥–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∞–≤—ã–π
        windowSum = windowSum - arr[i-k] + arr[i]
        maxSum = max(maxSum, windowSum)
    }
    
    return maxSum
}
```

### –ü—Ä–∏–º–µ—Ä 2: –î–ª–∏–Ω–µ–π—à–∞—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∞ –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π

```python
def longest_substring_without_repeating(s):
    """
    –î–ª–∏–Ω–µ–π—à–∞—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∞ –±–µ–∑ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è —Å–∏–º–≤–æ–ª–æ–≤
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(min(m, n)) –≥–¥–µ m - —Ä–∞–∑–º–µ—Ä –∞–ª—Ñ–∞–≤–∏—Ç–∞
    """
    char_set = set()
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª —É–∂–µ –µ—Å—Ç—å –≤ –æ–∫–Ω–µ, —Å–∂–∏–º–∞–µ–º –æ–∫–Ω–æ
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        
        # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —Å–∏–º–≤–æ–ª
        char_set.add(s[right])
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É
        max_length = max(max_length, right - left + 1)
    
    return max_length
```

---

## üèÉ Fast & Slow Pointers (–ë—ã—Å—Ç—Ä—ã–π –∏ –º–µ–¥–ª–µ–Ω–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª–∏)

### –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
- –ü–æ–∏—Å–∫ —Ü–∏–∫–ª–∞ –≤ —Å–≤—è–∑–Ω–æ–º —Å–ø–∏—Å–∫–µ
- –ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ —Å–µ—Ä–µ–¥–∏–Ω—ã —Å–ø–∏—Å–∫–∞
- –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–æ–≤

### –ü—Ä–∏–º–µ—Ä: –ü–æ–∏—Å–∫ —Ü–∏–∫–ª–∞ (Floyd's Algorithm)

```go
// ==================== –ü–û–ò–°–ö –¶–ò–ö–õ–ê –í –°–í–Ø–ó–ù–û–ú –°–ü–ò–°–ö–ï ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)

type ListNode struct {
    Val  int
    Next *ListNode
}

func hasCycle(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return false
    }
    
    // –ú–µ–¥–ª–µ–Ω–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å –¥–≤–∏–∂–µ—Ç—Å—è –Ω–∞ 1 —à–∞–≥
    slow := head
    // –ë—ã—Å—Ç—Ä—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å –¥–≤–∏–∂–µ—Ç—Å—è –Ω–∞ 2 —à–∞–≥–∞
    fast := head.Next
    
    // –ï—Å–ª–∏ –µ—Å—Ç—å —Ü–∏–∫–ª, –±—ã—Å—Ç—Ä—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å –¥–æ–≥–æ–Ω–∏—Ç –º–µ–¥–ª–µ–Ω–Ω—ã–π
    for slow != fast {
        // –ë—ã—Å—Ç—Ä—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å –¥–æ—à–µ–ª –¥–æ –∫–æ–Ω—Ü–∞ - –Ω–µ—Ç —Ü–∏–∫–ª–∞
        if fast == nil || fast.Next == nil {
            return false
        }
        
        slow = slow.Next      // +1 —à–∞–≥
        fast = fast.Next.Next // +2 —à–∞–≥–∞
    }
    
    return true  // –£–∫–∞–∑–∞—Ç–µ–ª–∏ –≤—Å—Ç—Ä–µ—Ç–∏–ª–∏—Å—å - –µ—Å—Ç—å —Ü–∏–∫–ª
}

// ==================== –ù–ê–•–û–ñ–î–ï–ù–ò–ï –ù–ê–ß–ê–õ–ê –¶–ò–ö–õ–ê ====================
func detectCycle(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return nil
    }
    
    // –§–∞–∑–∞ 1: –ü–æ–∏—Å–∫ –≤—Å—Ç—Ä–µ—á–∏ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
    slow := head
    fast := head
    
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        
        if slow == fast {
            break  // –ù–∞–π–¥–µ–Ω–∞ –≤—Å—Ç—Ä–µ—á–∞
        }
    }
    
    // –¶–∏–∫–ª–∞ –Ω–µ—Ç
    if fast == nil || fast.Next == nil {
        return nil
    }
    
    // –§–∞–∑–∞ 2: –ü–æ–∏—Å–∫ –Ω–∞—á–∞–ª–∞ —Ü–∏–∫–ª–∞
    // –û–¥–∏–Ω —É–∫–∞–∑–∞—Ç–µ–ª—å –≤ –Ω–∞—á–∞–ª–µ, –¥—Ä—É–≥–æ–π –≤ —Ç–æ—á–∫–µ –≤—Å—Ç—Ä–µ—á–∏
    slow = head
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }
    
    return slow  // –ù–∞—á–∞–ª–æ —Ü–∏–∫–ª–∞
}
```

---

## üå≥ Tree Traversal (–û–±—Ö–æ–¥ –¥–µ—Ä–µ–≤—å–µ–≤)

### DFS (Depth-First Search)

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# ==================== –†–ï–ö–£–†–°–ò–í–ù–´–ô DFS ====================
def dfs_recursive(root, result):
    """
    –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –æ–±—Ö–æ–¥ –¥–µ—Ä–µ–≤–∞ –≤ –≥–ª—É–±–∏–Ω—É
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(h) –≥–¥–µ h - –≤—ã—Å–æ—Ç–∞ –¥–µ—Ä–µ–≤–∞
    """
    if not root:
        return
    
    # Preorder: –∫–æ—Ä–µ–Ω—å -> –ª–µ–≤–æ–µ -> –ø—Ä–∞–≤–æ–µ
    result.append(root.val)
    dfs_recursive(root.left, result)
    dfs_recursive(root.right, result)

# ==================== –ò–¢–ï–†–ê–¢–ò–í–ù–´–ô DFS ====================
def dfs_iterative(root):
    """
    –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –æ–±—Ö–æ–¥ –¥–µ—Ä–µ–≤–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å—Ç–µ–∫–∞
    """
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å—Ç–µ–∫ —Å–ø—Ä–∞–≤–∞ –Ω–∞–ª–µ–≤–æ (–¥–ª—è left-first –æ–±—Ö–æ–¥–∞)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result
```

### BFS (Breadth-First Search)

```python
from collections import deque

def bfs_level_order(root):
    """
    –û–±—Ö–æ–¥ –¥–µ—Ä–µ–≤–∞ –ø–æ —É—Ä–æ–≤–Ω—è–º (BFS)
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(w) –≥–¥–µ w - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –¥–µ—Ä–µ–≤–∞
    """
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ —É–∑–ª—ã —Ç–µ–∫—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            # –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ç–µ–π –≤ –æ—á–µ—Ä–µ–¥—å
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result
```

---

## üé≠ Backtracking (–í–æ–∑–≤—Ä–∞—Ç)

### –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –∫–æ–º–±–∏–Ω–∞—Ü–∏–π
- –ü–æ–∏—Å–∫ –≤—Å–µ—Ö —Ä–µ—à–µ–Ω–∏–π
- –ó–∞–¥–∞—á–∏ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏

### –®–∞–±–ª–æ–Ω —Ä–µ—à–µ–Ω–∏—è

```python
def backtrack_template(candidates, target, current_combination, result):
    """
    –ë–∞–∑–æ–≤—ã–π —à–∞–±–ª–æ–Ω backtracking
    """
    # –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π: –Ω–∞–π–¥–µ–Ω–æ —Ä–µ—à–µ–Ω–∏–µ
    if is_valid_solution(current_combination, target):
        result.append(current_combination[:])  # –ö–æ–ø–∏—Ä—É–µ–º —Ä–µ—à–µ–Ω–∏–µ
        return
    
    # –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
    for candidate in candidates:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –¥–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
        if is_valid_choice(candidate, current_combination):
            # –î–æ–±–∞–≤–ª—è–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
            current_combination.append(candidate)
            
            # –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∏—â–µ–º –¥–∞–ª—å—à–µ
            backtrack_template(candidates, target, current_combination, result)
            
            # –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è (backtrack)
            current_combination.pop()
```

### –ü—Ä–∏–º–µ—Ä: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤

```python
def subsets(nums):
    """
    –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(2^n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n) - –≥–ª—É–±–∏–Ω–∞ —Ä–µ–∫—É—Ä—Å–∏–∏
    """
    result = []
    
    def backtrack(start, current_subset):
        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        result.append(current_subset[:])
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞, –¥–æ–±–∞–≤–ª—è—è —ç–ª–µ–º–µ–Ω—Ç—ã
        for i in range(start, len(nums)):
            # –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç
            current_subset.append(nums[i])
            
            # –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞
            backtrack(i + 1, current_subset)
            
            # –£–±–∏—Ä–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç (backtrack)
            current_subset.pop()
    
    backtrack(0, [])
    return result
```

---

## üîç Binary Search Pattern (–ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫)

### –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è

```python
def binary_search_pattern(arr, target):
    """
    –û–±–æ–±—â–µ–Ω–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if condition(arr[mid], target):
            return mid  # –ò–ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        elif should_search_left(arr[mid], target):
            right = mid - 1
        else:
            left = mid + 1
    
    return -1  # –ù–µ –Ω–∞–π–¥–µ–Ω–æ

# ==================== –ü–û–ò–°–ö –í –ü–û–í–ï–†–ù–£–¢–û–ú –ú–ê–°–°–ò–í–ï ====================
def search_rotated_array(nums, target):
    """
    –ü–æ–∏—Å–∫ –≤ –ø–æ–≤–µ—Ä–Ω—É—Ç–æ–º –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ
    """
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if nums[mid] == target:
            return mid
        
        # –õ–µ–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞
        if nums[left] <= nums[mid]:
            # –¶–µ–ª—å –≤ –ª–µ–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        # –ü—Ä–∞–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞
        else:
            # –¶–µ–ª—å –≤ –ø—Ä–∞–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1
```

---

## üèóÔ∏è Merge Intervals (–°–ª–∏—è–Ω–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤)

### –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
- –†–∞–±–æ—Ç–∞ —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞–º–∏
- –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏—Ö—Å—è –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤
- –ü–æ–∏—Å–∫ —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤

### –ü—Ä–∏–º–µ—Ä: –°–ª–∏—è–Ω–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤

```go
// ==================== –°–õ–ò–Ø–ù–ò–ï –ü–ï–†–ï–°–ï–ö–ê–Æ–©–ò–•–°–Ø –ò–ù–¢–ï–†–í–ê–õ–û–í ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n log n) - —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n) - —Ä–µ–∑—É–ª—å—Ç–∞—Ç

type Interval struct {
    Start int
    End   int
}

func merge(intervals []Interval) []Interval {
    if len(intervals) <= 1 {
        return intervals
    }
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –ø–æ –Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–æ—á–∫–µ
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].Start < intervals[j].Start
    })
    
    merged := []Interval{intervals[0]}
    
    for i := 1; i < len(intervals); i++ {
        current := intervals[i]
        last := &merged[len(merged)-1]
        
        // –ï—Å–ª–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è
        if current.Start <= last.End {
            // –û–±—ä–µ–¥–∏–Ω—è–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
            last.End = max(last.End, current.End)
        } else {
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
            merged = append(merged, current)
        }
    }
    
    return merged
}
```

---

## üîÑ Cyclic Sort (–¶–∏–∫–ª–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞)

### –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
- –ú–∞—Å—Å–∏–≤ —Å–æ–¥–µ—Ä–∂–∏—Ç —á–∏—Å–ª–∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [1, n]
- –ù—É–∂–Ω–æ –Ω–∞–π—Ç–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ/–¥—É–±–ª–∏—Ä—É—é—â–∏–µ—Å—è —á–∏—Å–ª–∞
- –¢—Ä–µ–±—É–µ—Ç—Å—è O(1) –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å

### –ü—Ä–∏–º–µ—Ä: –ù–∞–π—Ç–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ —á–∏—Å–ª–∞

```python
def find_missing_numbers(nums):
    """
    –ü–æ–∏—Å–∫ –≤—Å–µ—Ö –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [1, n]
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
    """
    i = 0
    n = len(nums)
    
    # –¶–∏–∫–ª–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: –ø–æ–º–µ—â–∞–µ–º –∫–∞–∂–¥–æ–µ —á–∏—Å–ª–æ –Ω–∞ —Å–≤–æ–µ –º–µ—Å—Ç–æ
    while i < n:
        # –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –¥–ª—è —á–∏—Å–ª–∞ nums[i] —ç—Ç–æ nums[i] - 1
        correct_pos = nums[i] - 1
        
        # –ï—Å–ª–∏ —á–∏—Å–ª–æ –Ω–µ –Ω–∞ —Å–≤–æ–µ–º –º–µ—Å—Ç–µ, –º–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏
        if nums[i] != nums[correct_pos]:
            nums[i], nums[correct_pos] = nums[correct_pos], nums[i]
        else:
            i += 1
    
    # –ù–∞—Ö–æ–¥–∏–º –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ —á–∏—Å–ª–∞
    missing = []
    for i in range(n):
        if nums[i] != i + 1:
            missing.append(i + 1)
    
    return missing
```

---

## üí° Dynamic Programming Patterns

### –û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã DP

```python
# ==================== –ü–ê–¢–¢–ï–†–ù 1: 0/1 KNAPSACK ====================
def knapsack_pattern(weights, values, capacity):
    """
    –ü–∞—Ç—Ç–µ—Ä–Ω —Ä—é–∫–∑–∞–∫–∞: –≤—ã–±–æ—Ä —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –≤—ã–≥–æ–¥–æ–π
    """
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i-1] <= w:
                # –í—ã–±–∏—Ä–∞–µ–º –º–∞–∫—Å–∏–º—É–º: –±—Ä–∞—Ç—å –∏–ª–∏ –Ω–µ –±—Ä–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç
                dp[i][w] = max(
                    dp[i-1][w],  # –ù–µ –±–µ—Ä–µ–º
                    dp[i-1][w-weights[i-1]] + values[i-1]  # –ë–µ—Ä–µ–º
                )
            else:
                dp[i][w] = dp[i-1][w]  # –≠–ª–µ–º–µ–Ω—Ç –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è
    
    return dp[n][capacity]

# ==================== –ü–ê–¢–¢–ï–†–ù 2: LONGEST COMMON SUBSEQUENCE ====================
def lcs_pattern(text1, text2):
    """
    –ü–∞—Ç—Ç–µ—Ä–Ω –Ω–∞–∏–±–æ–ª—å—à–µ–π –æ–±—â–µ–π –ø–æ–¥–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    """
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1  # –°–∏–º–≤–æ–ª—ã —Å–æ–≤–ø–∞–¥–∞—é—Ç
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])  # –ë–µ—Ä–µ–º –ª—É—á—à–∏–π –≤–∞—Ä–∏–∞–Ω—Ç
    
    return dp[m][n]
```

---

## üéØ –ö–∞–∫ –ø—Ä–∏–º–µ–Ω—è—Ç—å –ø–∞—Ç—Ç–µ—Ä–Ω—ã –Ω–∞ –∏–Ω—Ç–µ—Ä–≤—å—é

### –ü–æ—à–∞–≥–æ–≤—ã–π –ø–æ–¥—Ö–æ–¥

1. **–ü–æ–Ω–∏–º–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏ (2 –º–∏–Ω—É—Ç—ã)**
   - –ü—Ä–æ—á–∏—Ç–∞—Ç—å —É—Å–ª–æ–≤–∏–µ –¥–≤–∞–∂–¥—ã
   - –ó–∞–¥–∞—Ç—å —É—Ç–æ—á–Ω—è—é—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã
   - –†–∞–∑–æ–±—Ä–∞—Ç—å –ø—Ä–∏–º–µ—Ä—ã

2. **–í—ã–±–æ—Ä –ø–∞—Ç—Ç–µ—Ä–Ω–∞ (1 –º–∏–Ω—É—Ç–∞)**
   - –û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ ‚Üí Two Pointers/Binary Search
   - –ü–æ–¥–º–∞—Å—Å–∏–≤/–ø–æ–¥—Å—Ç—Ä–æ–∫–∞ ‚Üí Sliding Window
   - –°–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫ + —Ü–∏–∫–ª ‚Üí Fast & Slow Pointers
   - –î–µ—Ä–µ–≤–æ ‚Üí DFS/BFS
   - –í—Å–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ ‚Üí Backtracking

3. **–û–±—ä—è—Å–Ω–µ–Ω–∏–µ –ø–æ–¥—Ö–æ–¥–∞ (2 –º–∏–Ω—É—Ç—ã)**
   - –ù–∞–∑–≤–∞—Ç—å –ø–∞—Ç—Ç–µ—Ä–Ω
   - –û–±—ä—è—Å–Ω–∏—Ç—å –ª–æ–≥–∏–∫—É
   - –û—Ü–µ–Ω–∏—Ç—å —Å–ª–æ–∂–Ω–æ—Å—Ç—å

4. **–†–µ–∞–ª–∏–∑–∞—Ü–∏—è (15-20 –º–∏–Ω—É—Ç)**
   - –ù–∞—á–∞—Ç—å —Å —à–∞–±–ª–æ–Ω–∞
   - –ê–¥–∞–ø—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ–¥ –∑–∞–¥–∞—á—É
   - –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ –ø—Ä–∏–º–µ—Ä–∞—Ö

5. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è (5 –º–∏–Ω—É—Ç)**
   - –ú–æ–∂–Ω–æ –ª–∏ —É–ª—É—á—à–∏—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏?
   - –ú–æ–∂–Ω–æ –ª–∏ —É–ª—É—á—à–∏—Ç—å –ø–æ –ø–∞–º—è—Ç–∏?
   - –ö—Ä–∞–µ–≤—ã–µ —Å–ª—É—á–∞–∏

---

## üèÜ –¢–æ–ø-10 –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –¥–ª—è FAANG

1. **Two Pointers** - 15% –∑–∞–¥–∞—á
2. **Sliding Window** - 12% –∑–∞–¥–∞—á
3. **Binary Search** - 10% –∑–∞–¥–∞—á
4. **DFS/BFS** - 15% –∑–∞–¥–∞—á
5. **Dynamic Programming** - 20% –∑–∞–¥–∞—á
6. **Backtracking** - 8% –∑–∞–¥–∞—á
7. **Greedy** - 10% –∑–∞–¥–∞—á
8. **Merge Intervals** - 5% –∑–∞–¥–∞—á
9. **Cyclic Sort** - 3% –∑–∞–¥–∞—á
10. **Topological Sort** - 2% –∑–∞–¥–∞—á

---

*–ü–∞—Ç—Ç–µ—Ä–Ω—ã - —ç—Ç–æ –º—ã—à—Ü—ã —Ä–∞–∑—É–º–∞. –ß–µ–º –±–æ–ª—å—à–µ —Ç—Ä–µ–Ω–∏—Ä—É–µ—à—å—Å—è, —Ç–µ–º –±—ã—Å—Ç—Ä–µ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–µ—à—å —Ä–µ—à–µ–Ω–∏—è* üß†üí™ 