# –ê–ª–≥–æ—Ä–∏—Ç–º—ã

> **–û—Å–Ω–æ–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤**
>
> –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞, –ø–æ–∏—Å–∫, —Ä–µ–∫—É—Ä—Å–∏—è –∏ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ

## üìã –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤

### –ü–æ —Ç–∏–ø—É –∑–∞–¥–∞—á
```
üîç –ü–û–ò–°–ö
‚îú‚îÄ‚îÄ –õ–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫ O(n)
‚îú‚îÄ‚îÄ –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ O(log n)
‚îî‚îÄ‚îÄ –ü–æ–∏—Å–∫ –≤ —Ö—ç—à-—Ç–∞–±–ª–∏—Ü–µ O(1)

üìä –°–û–†–¢–ò–†–û–í–ö–ê
‚îú‚îÄ‚îÄ –ü—Ä–æ—Å—Ç—ã–µ: Bubble O(n¬≤), Selection O(n¬≤)
‚îú‚îÄ‚îÄ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–µ: Merge O(n log n), Quick O(n log n)
‚îî‚îÄ‚îÄ –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ: Counting O(n+k), Radix O(d√ón)

üîÑ –†–ï–ö–£–†–°–ò–Ø
‚îú‚îÄ‚îÄ Divide & Conquer
‚îú‚îÄ‚îÄ Backtracking
‚îî‚îÄ‚îÄ Dynamic Programming
```

---

## üîç –ê–ª–≥–æ—Ä–∏—Ç–º—ã –ø–æ–∏—Å–∫–∞

### –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫

```go
// ==================== –ë–ò–ù–ê–†–ù–´–ô –ü–û–ò–°–ö ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(log n)
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    
    for left <= right {
        // –ò–∑–±–µ–≥–∞–µ–º –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–∏ (left + right) / 2
        mid := left + (right-left)/2
        
        if arr[mid] == target {
            return mid  // –ù–∞–π–¥–µ–Ω!
        } else if arr[mid] < target {
            left = mid + 1  // –ò—â–µ–º –≤ –ø—Ä–∞–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
        } else {
            right = mid - 1  // –ò—â–µ–º –≤ –ª–µ–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
        }
    }
    
    return -1  // –ù–µ –Ω–∞–π–¥–µ–Ω
}

// ==================== –ü–û–ò–°–ö –ì–†–ê–ù–ò–¶ ====================
// –ù–∞–π—Ç–∏ –ø–µ—Ä–≤–æ–µ –∏ –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞
func searchRange(nums []int, target int) []int {
    left := findFirst(nums, target)
    if left == -1 {
        return []int{-1, -1}
    }
    
    right := findLast(nums, target)
    return []int{left, right}
}

func findFirst(nums []int, target int) int {
    left, right := 0, len(nums)-1
    result := -1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if nums[mid] == target {
            result = mid      // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
            right = mid - 1   // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–æ–∏—Å–∫ –≤–ª–µ–≤–æ
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return result
}
```

---

## üìä –ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏

### Merge Sort (–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å–ª–∏—è–Ω–∏–µ–º)

```python
def merge_sort(arr):
    """
    –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å–ª–∏—è–Ω–∏–µ–º - —Å—Ç–∞–±–∏–ª—å–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n log n) –≤–æ –≤—Å–µ—Ö —Å–ª—É—á–∞—è—Ö
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
    """
    if len(arr) <= 1:
        return arr
    
    # –î–µ–ª–∏–º –º–∞—Å—Å–∏–≤ –ø–æ–ø–æ–ª–∞–º
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])    # –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ª–µ–≤—É—é —á–∞—Å—Ç—å
    right = merge_sort(arr[mid:])   # –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø—Ä–∞–≤—É—é —á–∞—Å—Ç—å
    
    # –°–ª–∏–≤–∞–µ–º –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —á–∞—Å—Ç–∏
    return merge(left, right)

def merge(left, right):
    """
    –°–ª–∏—è–Ω–∏–µ –¥–≤—É—Ö –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
    """
    result = []
    i = j = 0
    
    # –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –∏ –¥–æ–±–∞–≤–ª—è–µ–º –º–µ–Ω—å—à–∏–π
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —ç–ª–µ–º–µ–Ω—Ç—ã
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result
```

### Quick Sort (–ë—ã—Å—Ç—Ä–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞)

```go
// ==================== –ë–´–°–¢–†–ê–Ø –°–û–†–¢–ò–†–û–í–ö–ê ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n log n) –≤ —Å—Ä–µ–¥–Ω–µ–º, O(n¬≤) –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(log n) - —Å—Ç–µ–∫ —Ä–µ–∫—É—Ä—Å–∏–∏
func quickSort(arr []int, low, high int) {
    if low < high {
        // –†–∞–∑–¥–µ–ª—è–µ–º –º–∞—Å—Å–∏–≤ –∏ –ø–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –æ–ø–æ—Ä–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
        pi := partition(arr, low, high)
        
        // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–æ—Ä—Ç–∏—Ä—É–µ–º —á–∞—Å—Ç–∏ –¥–æ –∏ –ø–æ—Å–ª–µ –æ–ø–æ—Ä–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    // –í—ã–±–∏—Ä–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –∫–∞–∫ –æ–ø–æ—Ä–Ω—ã–π (pivot)
    pivot := arr[high]
    
    // –ò–Ω–¥–µ–∫—Å –º–µ–Ω—å—à–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ - —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é pivot
    i := low - 1
    
    for j := low; j < high; j++ {
        // –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –º–µ–Ω—å—à–µ –∏–ª–∏ —Ä–∞–≤–µ–Ω –æ–ø–æ—Ä–Ω–æ–º—É
        if arr[j] <= pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]  // –ú–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏
        }
    }
    
    // –°—Ç–∞–≤–∏–º –æ–ø–æ—Ä–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
    arr[i+1], arr[high] = arr[high], arr[i+1]
    
    return i + 1
}

// ==================== –£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø –° –°–õ–£–ß–ê–ô–ù–´–ú PIVOT ====================
func quickSortRandomized(arr []int, low, high int) {
    if low < high {
        // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π pivot –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è —Ö—É–¥—à–µ–≥–æ —Å–ª—É—á–∞—è
        randomPivot := low + rand.Intn(high-low+1)
        arr[randomPivot], arr[high] = arr[high], arr[randomPivot]
        
        pi := partition(arr, low, high)
        quickSortRandomized(arr, low, pi-1)
        quickSortRandomized(arr, pi+1, high)
    }
}
```

---

## üîÑ –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ

### –ß–∏—Å–ª–∞ –§–∏–±–æ–Ω–∞—á—á–∏

```python
# ==================== –ù–ê–ò–í–ù–ê–Ø –†–ï–ö–£–†–°–ò–Ø O(2^n) ====================
def fibonacci_naive(n):
    """–ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç—å—é"""
    if n <= 1:
        return n
    return fibonacci_naive(n-1) + fibonacci_naive(n-2)

# ==================== –ú–ï–ú–û–ò–ó–ê–¶–ò–Ø O(n) ====================
def fibonacci_memo(n, memo={}):
    """–ú–µ–º–æ–∏–∑–∞—Ü–∏—è - –∑–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
    if n in memo:
        return memo[n]
    
    if n <= 1:
        return n
    
    # –í—ã—á–∏—Å–ª—è–µ–º –∏ –∑–∞–ø–æ–º–∏–Ω–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)
    return memo[n]

# ==================== –¢–ê–ë–£–õ–Ø–¶–ò–Ø O(n) ====================
def fibonacci_dp(n):
    """Bottom-up –ø–æ–¥—Ö–æ–¥ —Å –º–∞—Å—Å–∏–≤–æ–º"""
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

# ==================== –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å ====================
def fibonacci_optimized(n):
    """–ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –¥–≤–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤–º–µ—Å—Ç–æ –º–∞—Å—Å–∏–≤–∞"""
    if n <= 1:
        return n
    
    prev2, prev1 = 0, 1
    
    for i in range(2, n + 1):
        current = prev1 + prev2
        prev2, prev1 = prev1, current
    
    return prev1
```

### –ó–∞–¥–∞—á–∞ –æ —Ä—é–∫–∑–∞–∫–µ

```go
// ==================== –ó–ê–î–ê–ß–ê –û –†–Æ–ö–ó–ê–ö–ï 0/1 ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n * W), –≥–¥–µ n - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–µ–¥–º–µ—Ç–æ–≤, W - –≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n * W)

func knapsack(weights []int, values []int, capacity int) int {
    n := len(weights)
    
    // dp[i][w] = –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–µ—Ä–≤—ã—Ö i –ø—Ä–µ–¥–º–µ—Ç–æ–≤
    // –∏ –≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å—é w
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
    for i := 1; i <= n; i++ {
        for w := 0; w <= capacity; w++ {
            // –ï—Å–ª–∏ –ø—Ä–µ–¥–º–µ—Ç –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è
            if weights[i-1] > w {
                dp[i][w] = dp[i-1][w]  // –ù–µ –±–µ—Ä–µ–º –ø—Ä–µ–¥–º–µ—Ç
            } else {
                // –í—ã–±–∏—Ä–∞–µ–º –º–∞–∫—Å–∏–º—É–º –º–µ–∂–¥—É:
                // 1. –ù–µ –±–µ—Ä–µ–º –ø—Ä–µ–¥–º–µ—Ç: dp[i-1][w]
                // 2. –ë–µ—Ä–µ–º –ø—Ä–µ–¥–º–µ—Ç: values[i-1] + dp[i-1][w-weights[i-1]]
                take := values[i-1] + dp[i-1][w-weights[i-1]]
                notTake := dp[i-1][w]
                dp[i][w] = max(take, notTake)
            }
        }
    }
    
    return dp[n][capacity]
}

// ==================== –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø O(W) –ü–ê–ú–Ø–¢–ò ====================
func knapsackOptimized(weights []int, values []int, capacity int) int {
    n := len(weights)
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –º–∞—Å—Å–∏–≤ –≤–º–µ—Å—Ç–æ 2D —Ç–∞–±–ª–∏—Ü—ã
    dp := make([]int, capacity+1)
    
    for i := 0; i < n; i++ {
        // –ò–¥–µ–º —Å–ø—Ä–∞–≤–∞ –Ω–∞–ª–µ–≤–æ —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –Ω—É–∂–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        for w := capacity; w >= weights[i]; w-- {
            dp[w] = max(dp[w], dp[w-weights[i]]+values[i])
        }
    }
    
    return dp[capacity]
}
```

---

## üî¢ –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã

### –ê–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞ (–ù–û–î)

```python
def gcd(a, b):
    """
    –ù–∞–∏–±–æ–ª—å—à–∏–π –æ–±—â–∏–π –¥–µ–ª–∏—Ç–µ–ª—å - –∞–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(log(min(a, b)))
    """
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    """
    –ù–∞–∏–º–µ–Ω—å—à–µ–µ –æ–±—â–µ–µ –∫—Ä–∞—Ç–Ω–æ–µ
    –ù–û–ö(a, b) = (a * b) / –ù–û–î(a, b)
    """
    return abs(a * b) // gcd(a, b)

# ==================== –†–ê–°–®–ò–†–ï–ù–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú –ï–í–ö–õ–ò–î–ê ====================
def extended_gcd(a, b):
    """
    –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞
    –ù–∞—Ö–æ–¥–∏—Ç –ù–û–î –∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã x, y —Ç–∞–∫–∏–µ —á—Ç–æ ax + by = –ù–û–î(a, b)
    """
    if a == 0:
        return b, 0, 1
    
    gcd_val, x1, y1 = extended_gcd(b % a, a)
    
    x = y1 - (b // a) * x1
    y = x1
    
    return gcd_val, x, y
```

### –ë—ã—Å—Ç—Ä–æ–µ –≤–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å

```go
// ==================== –ë–´–°–¢–†–û–ï –í–û–ó–í–ï–î–ï–ù–ò–ï –í –°–¢–ï–ü–ï–ù–¨ ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(log n)
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
func fastPower(base, exponent int) int {
    result := 1
    
    for exponent > 0 {
        // –ï—Å–ª–∏ —Å—Ç–µ–ø–µ–Ω—å –Ω–µ—á–µ—Ç–Ω–∞—è, —É–º–Ω–æ–∂–∞–µ–º –Ω–∞ base
        if exponent%2 == 1 {
            result *= base
        }
        
        // –í–æ–∑–≤–æ–¥–∏–º base –≤ –∫–≤–∞–¥—Ä–∞—Ç –∏ –¥–µ–ª–∏–º —Å—Ç–µ–ø–µ–Ω—å –ø–æ–ø–æ–ª–∞–º
        base *= base
        exponent /= 2
    }
    
    return result
}

// ==================== –° –ú–û–î–£–õ–ï–ú (–¥–ª—è –±–æ–ª—å—à–∏—Ö —á–∏—Å–µ–ª) ====================
func fastPowerMod(base, exponent, mod int) int {
    result := 1
    base = base % mod
    
    for exponent > 0 {
        if exponent%2 == 1 {
            result = (result * base) % mod
        }
        
        exponent = exponent >> 1  // –î–µ–ª–µ–Ω–∏–µ –Ω–∞ 2 —á–µ—Ä–µ–∑ –±–∏—Ç–æ–≤—ã–π —Å–¥–≤–∏–≥
        base = (base * base) % mod
    }
    
    return result
}
```

---

## üßÆ –ê–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–∞ —Å—Ç—Ä–æ–∫–∞—Ö

### –ü–æ–∏—Å–∫ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ (KMP)

```python
def kmp_search(text, pattern):
    """
    –ü–æ–∏—Å–∫ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º –ö–Ω—É—Ç–∞-–ú–æ—Ä—Ä–∏—Å–∞-–ü—Ä–∞—Ç—Ç–∞
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n + m)
    –≥–¥–µ n - –¥–ª–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞, m - –¥–ª–∏–Ω–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–∞
    """
    def compute_lps(pattern):
        """–í—ã—á–∏—Å–ª—è–µ–º –º–∞—Å—Å–∏–≤ LPS (Longest Proper Prefix Suffix)"""
        m = len(pattern)
        lps = [0] * m
        length = 0
        i = 1
        
        while i < m:
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
        
        return lps
    
    n = len(text)
    m = len(pattern)
    
    if m == 0:
        return []
    
    lps = compute_lps(pattern)
    matches = []
    
    i = 0  # –ò–Ω–¥–µ–∫—Å –¥–ª—è text
    j = 0  # –ò–Ω–¥–µ–∫—Å –¥–ª—è pattern
    
    while i < n:
        if pattern[j] == text[i]:
            i += 1
            j += 1
        
        if j == m:
            matches.append(i - j)  # –ù–∞–π–¥–µ–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
            j = lps[j - 1]
        elif i < n and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return matches
```

---

## üåê –ê–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–∞ –≥—Ä–∞—Ñ–∞—Ö

### –ü–æ–∏—Å–∫ –≤ —à–∏—Ä–∏–Ω—É (BFS)

```go
// ==================== BFS –î–õ–Ø –ü–û–ò–°–ö–ê –ö–†–ê–¢–ß–ê–ô–®–ï–ì–û –ü–£–¢–ò ====================
func bfs(graph [][]int, start, end int) []int {
    if start == end {
        return []int{start}
    }
    
    visited := make([]bool, len(graph))
    queue := []int{start}
    parent := make([]int, len(graph))
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º parent –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ -1
    for i := range parent {
        parent[i] = -1
    }
    
    visited[start] = true
    
    for len(queue) > 0 {
        current := queue[0]
        queue = queue[1:]  // –£–¥–∞–ª—è–µ–º –∏–∑ –Ω–∞—á–∞–ª–∞ –æ—á–µ—Ä–µ–¥–∏
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ—Ö —Å–æ—Å–µ–¥–µ–π
        for _, neighbor := range graph[current] {
            if !visited[neighbor] {
                visited[neighbor] = true
                parent[neighbor] = current
                queue = append(queue, neighbor)
                
                // –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ —Ü–µ–ª–∏, –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—É—Ç—å
                if neighbor == end {
                    return reconstructPath(parent, start, end)
                }
            }
        }
    }
    
    return nil  // –ü—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω
}

func reconstructPath(parent []int, start, end int) []int {
    path := []int{}
    current := end
    
    // –ò–¥–µ–º –æ—Ç –∫–æ–Ω—Ü–∞ –∫ –Ω–∞—á–∞–ª—É —á–µ—Ä–µ–∑ parent
    for current != -1 {
        path = append([]int{current}, path...)  // –î–æ–±–∞–≤–ª—è–µ–º –≤ –Ω–∞—á–∞–ª–æ
        current = parent[current]
    }
    
    return path
}
```

---

## üîç –ê–ª–≥–æ—Ä–∏—Ç–º—ã –ø–æ–∏—Å–∫–∞ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

### –¢–µ—Ä–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫

```python
def ternary_search(arr, left, right, target):
    """
    –¢–µ—Ä–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ –¥–ª—è —É–Ω–∏–º–æ–¥–∞–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(log‚ÇÉ n)
    """
    if right >= left:
        # –î–µ–ª–∏–º –Ω–∞ —Ç—Ä–∏ —á–∞—Å—Ç–∏
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
        
        if arr[mid1] == target:
            return mid1
        if arr[mid2] == target:
            return mid2
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –≤ –∫–∞–∫–æ–π —Ç—Ä–µ—Ç–∏ –∏—Å–∫–∞—Ç—å
        if target < arr[mid1]:
            return ternary_search(arr, left, mid1 - 1, target)
        elif target > arr[mid2]:
            return ternary_search(arr, mid2 + 1, right, target)
        else:
            return ternary_search(arr, mid1 + 1, mid2 - 1, target)
    
    return -1

# ==================== –ü–û–ò–°–ö –ú–ê–ö–°–ò–ú–£–ú–ê –£–ù–ò–ú–û–î–ê–õ–¨–ù–û–ô –§–£–ù–ö–¶–ò–ò ====================
def find_maximum_ternary(func, left, right, precision=1e-9):
    """
    –ü–æ–∏—Å–∫ –º–∞–∫—Å–∏–º—É–º–∞ —É–Ω–∏–º–æ–¥–∞–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–µ—Ä–Ω–∞—Ä–Ω—ã–º –ø–æ–∏—Å–∫–æ–º
    """
    while right - left > precision:
        m1 = left + (right - left) / 3
        m2 = right - (right - left) / 3
        
        if func(m1) < func(m2):
            left = m1
        else:
            right = m2
    
    return (left + right) / 2
```

---

## üìä –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤

| –ê–ª–≥–æ—Ä–∏—Ç–º | –õ—É—á—à–∏–π —Å–ª—É—á–∞–π | –°—Ä–µ–¥–Ω–∏–π —Å–ª—É—á–∞–π | –•—É–¥—à–∏–π —Å–ª—É—á–∞–π | –ü–∞–º—è—Ç—å |
|----------|---------------|----------------|---------------|---------|
| **–ü–æ–∏—Å–∫** |
| –õ–∏–Ω–µ–π–Ω—ã–π | O(1) | O(n) | O(n) | O(1) |
| –ë–∏–Ω–∞—Ä–Ω—ã–π | O(1) | O(log n) | O(log n) | O(1) |
| **–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞** |
| Bubble Sort | O(n) | O(n¬≤) | O(n¬≤) | O(1) |
| Quick Sort | O(n log n) | O(n log n) | O(n¬≤) | O(log n) |
| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) |
| Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) |

---

## üéØ –°–æ–≤–µ—Ç—ã –ø–æ –≤—ã–±–æ—Ä—É –∞–ª–≥–æ—Ä–∏—Ç–º–∞

### –î–ª—è –ø–æ–∏—Å–∫–∞
- **–ù–µ—É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:** –õ–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫ O(n)
- **–£–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:** –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ O(log n)
- **–ß–∞—Å—Ç—ã–µ –ø–æ–∏—Å–∫–∏:** –•—ç—à-—Ç–∞–±–ª–∏—Ü–∞ O(1)

### –î–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
- **–ú–∞–ª—ã–µ –¥–∞–Ω–Ω—ã–µ (< 50 —ç–ª–µ–º–µ–Ω—Ç–æ–≤):** Insertion Sort
- **–°—Ä–µ–¥–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ:** Quick Sort
- **–ë–æ–ª—å—à–∏–µ –¥–∞–Ω–Ω—ã–µ:** Merge Sort
- **–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å –≤–∞–∂–Ω–∞:** Merge Sort
- **–ú–∏–Ω–∏–º—É–º –ø–∞–º—è—Ç–∏:** Heap Sort

### –î–ª—è —Å—Ç—Ä–æ–∫
- **–û–¥–∏–Ω –ø–æ–∏—Å–∫:** –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
- **–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø–æ–∏—Å–∫–∏:** KMP, Rabin-Karp
- **–ü–æ–∏—Å–∫ –ø–æ —à–∞–±–ª–æ–Ω—É:** –†–µ–≥—É–ª—è—Ä–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è

---

*–•–æ—Ä–æ—à–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º ‚Äî —ç—Ç–æ –Ω–µ —Å–∞–º—ã–π —É–º–Ω—ã–π, –∞ —Å–∞–º—ã–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π –¥–ª—è –∑–∞–¥–∞—á–∏* üéØ 