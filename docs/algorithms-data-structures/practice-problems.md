# –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏

> **–°–±–æ—Ä–Ω–∏–∫ –∑–∞–¥–∞—á –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∏—á–µ—Å–∫–æ–≥–æ –º—ã—à–ª–µ–Ω–∏—è**
>
> –û—Ç –±–∞–∑–æ–≤—ã—Ö –¥–æ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö —Å –¥–µ—Ç–∞–ª—å–Ω—ã–º–∏ —Ä–µ—à–µ–Ω–∏—è–º–∏ –∏ –æ–±—ä—è—Å–Ω–µ–Ω–∏—è–º–∏

## üéØ –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–æ—Ç —Ä–∞–∑–¥–µ–ª

### –ü–æ–¥—Ö–æ–¥ –∫ —Ä–µ—à–µ–Ω–∏—é –∑–∞–¥–∞—á
1. **–ü—Ä–æ—á–∏—Ç–∞—Ç—å —É—Å–ª–æ–≤–∏–µ** - –ø–æ–Ω—è—Ç—å —á—Ç–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è
2. **–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏–º–µ—Ä—ã** - –Ω–∞–π—Ç–∏ –∑–∞–∫–æ–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç–∏
3. **–í—ã–±—Ä–∞—Ç—å –ø–æ–¥—Ö–æ–¥** - –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–∞—Ç—Ç–µ—Ä–Ω —Ä–µ—à–µ–Ω–∏—è
4. **–û—Ü–µ–Ω–∏—Ç—å —Å–ª–æ–∂–Ω–æ—Å—Ç—å** - –≤—Ä–µ–º—è –∏ –ø–∞–º—è—Ç—å
5. **–ù–∞–ø–∏—Å–∞—Ç—å –∫–æ–¥** - —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ä–µ—à–µ–Ω–∏–µ
6. **–ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å** - –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞ –ø—Ä–∏–º–µ—Ä–∞—Ö

---

## üìä –ó–∞–¥–∞—á–∏ –ø–æ —É—Ä–æ–≤–Ω—è–º —Å–ª–æ–∂–Ω–æ—Å—Ç–∏

### üü¢ –õ–µ–≥–∫–∏–µ –∑–∞–¥–∞—á–∏ (Easy)

#### –ó–∞–¥–∞—á–∞ 1: –ü–∞–ª–∏–Ω–¥—Ä–æ–º
```python
# ==================== –ó–ê–î–ê–ß–ê: –ü–†–û–í–ï–†–ö–ê –ü–ê–õ–ò–ù–î–†–û–ú–ê ====================
# –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–æ–º (—á–∏—Ç–∞–µ—Ç—Å—è –æ–¥–∏–Ω–∞–∫–æ–≤–æ —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ –∏ —Å–ø—Ä–∞–≤–∞ –Ω–∞–ª–µ–≤–æ)
# –£—á–∏—Ç—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã –∏ —Ü–∏—Ñ—Ä—ã, –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä

def is_palindrome(s):
    """
    –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞
    
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
    
    –ü–∞—Ç—Ç–µ—Ä–Ω: Two Pointers
    """
    # –ü—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É –∏ –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã/—Ü–∏—Ñ—Ä—ã
    cleaned = ''.join(char.lower() for char in s if char.isalnum())
    
    # –î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è —Å –∫–æ–Ω—Ü–æ–≤ —Å—Ç—Ä–æ–∫–∏
    left, right = 0, len(cleaned) - 1
    
    while left < right:
        if cleaned[left] != cleaned[right]:
            return False
        left += 1
        right -= 1
    
    return True

# ==================== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï ====================
def test_palindrome():
    assert is_palindrome("A man, a plan, a canal: Panama") == True
    assert is_palindrome("race a car") == False
    assert is_palindrome("") == True
    assert is_palindrome("Madam") == True
    print("‚úÖ –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã!")

# ==================== –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ù–û–ï –†–ï–®–ï–ù–ò–ï ====================
def is_palindrome_recursive(s):
    """
    –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞
    """
    def helper(left, right):
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ –±—É–∫–≤–µ–Ω–Ω–æ-—Ü–∏—Ñ—Ä–æ–≤—ã–µ —Å–∏–º–≤–æ–ª—ã
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        
        # –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π
        if left >= right:
            return True
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–µ —Å–∏–º–≤–æ–ª—ã
        if s[left].lower() != s[right].lower():
            return False
        
        return helper(left + 1, right - 1)
    
    return helper(0, len(s) - 1)
```

#### –ó–∞–¥–∞—á–∞ 2: –ê–Ω–∞–≥—Ä–∞–º–º—ã
```python
# ==================== –ó–ê–î–ê–ß–ê: –í–ê–õ–ò–î–ù–´–ï –ê–ù–ê–ì–†–ê–ú–ú–´ ====================
# –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è—é—Ç—Å—è –ª–∏ –¥–≤–µ —Å—Ç—Ä–æ–∫–∏ –∞–Ω–∞–≥—Ä–∞–º–º–∞–º–∏

def is_anagram(s, t):
    """
    –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–Ω–∞–≥—Ä–∞–º–º
    
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1) - —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∞–ª—Ñ–∞–≤–∏—Ç–∞
    
    –ü–∞—Ç—Ç–µ—Ä–Ω: Hash Map (Counter)
    """
    if len(s) != len(t):
        return False
    
    # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —á–∞—Å—Ç–æ—Ç—É —Å–∏–º–≤–æ–ª–æ–≤
    char_count = {}
    
    # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –¥–ª—è –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏
    for char in s:
        char_count[char] = char_count.get(char, 0) + 1
    
    # –£–º–µ–Ω—å—à–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –¥–ª—è –≤—Ç–æ—Ä–æ–π —Å—Ç—Ä–æ–∫–∏
    for char in t:
        if char not in char_count:
            return False
        char_count[char] -= 1
        if char_count[char] == 0:
            del char_count[char]
    
    return len(char_count) == 0

# ==================== –†–ï–®–ï–ù–ò–ï –ß–ï–†–ï–ó –°–û–†–¢–ò–†–û–í–ö–£ ====================
def is_anagram_sort(s, t):
    """
    –†–µ—à–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫—É
    
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n log n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
    """
    return sorted(s) == sorted(t)

# ==================== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï ====================
def test_anagram():
    assert is_anagram("anagram", "nagaram") == True
    assert is_anagram("rat", "car") == False
    assert is_anagram("listen", "silent") == True
    print("‚úÖ –ê–Ω–∞–≥—Ä–∞–º–º—ã: –≤—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã!")
```

### üü° –°—Ä–µ–¥–Ω–∏–µ –∑–∞–¥–∞—á–∏ (Medium)

#### –ó–∞–¥–∞—á–∞ 3: –ü–æ–∏—Å–∫ –≤ –ø–æ–≤–µ—Ä–Ω—É—Ç–æ–º –º–∞—Å—Å–∏–≤–µ
```python
# ==================== –ó–ê–î–ê–ß–ê: –ü–û–ò–°–ö –í –ü–û–í–ï–†–ù–£–¢–û–ú –ú–ê–°–°–ò–í–ï ====================
# –ù–∞–π—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ, –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª –ø–æ–≤–µ—Ä–Ω—É—Ç

def search_rotated_array(nums, target):
    """
    –ü–æ–∏—Å–∫ –≤ –ø–æ–≤–µ—Ä–Ω—É—Ç–æ–º –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ
    
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(log n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
    
    –ü–∞—Ç—Ç–µ—Ä–Ω: Modified Binary Search
    """
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞
        if nums[left] <= nums[mid]:
            # –õ–µ–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            # –ü—Ä–∞–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1

# ==================== –ü–û–ò–°–ö –ú–ò–ù–ò–ú–£–ú–ê –í –ü–û–í–ï–†–ù–£–¢–û–ú –ú–ê–°–°–ò–í–ï ====================
def find_min_rotated(nums):
    """
    –ü–æ–∏—Å–∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –ø–æ–≤–µ—Ä–Ω—É—Ç–æ–º –º–∞—Å—Å–∏–≤–µ
    
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(log n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
    """
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        if nums[mid] > nums[right]:
            # –ú–∏–Ω–∏–º—É–º –≤ –ø—Ä–∞–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
            left = mid + 1
        else:
            # –ú–∏–Ω–∏–º—É–º –≤ –ª–µ–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ –∏–ª–∏ mid - –º–∏–Ω–∏–º—É–º
            right = mid
    
    return nums[left]

# ==================== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï ====================
def test_rotated_search():
    assert search_rotated_array([4,5,6,7,0,1,2], 0) == 4
    assert search_rotated_array([4,5,6,7,0,1,2], 3) == -1
    assert find_min_rotated([3,4,5,1,2]) == 1
    assert find_min_rotated([4,5,6,7,0,1,2]) == 0
    print("‚úÖ –ü–æ–∏—Å–∫ –≤ –ø–æ–≤–µ—Ä–Ω—É—Ç–æ–º –º–∞—Å—Å–∏–≤–µ: –≤—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã!")
```

#### –ó–∞–¥–∞—á–∞ 4: –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∞–Ω–∞–≥—Ä–∞–º–º
```python
# ==================== –ó–ê–î–ê–ß–ê: –ì–†–£–ü–ü–ò–†–û–í–ö–ê –ê–ù–ê–ì–†–ê–ú–ú ====================
# –°–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å –∞–Ω–∞–≥—Ä–∞–º–º—ã –∏–∑ –º–∞—Å—Å–∏–≤–∞ —Å—Ç—Ä–æ–∫

def group_anagrams(strs):
    """
    –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∞–Ω–∞–≥—Ä–∞–º–º
    
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n * m log m), –≥–¥–µ n - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫, m - —Å—Ä–µ–¥–Ω—è—è –¥–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n * m)
    
    –ü–∞—Ç—Ç–µ—Ä–Ω: Hash Map —Å —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–æ–π –∫–∞–∫ –∫–ª—é—á
    """
    from collections import defaultdict
    
    anagram_groups = defaultdict(list)
    
    for s in strs:
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –∫–∞–∫ –∫–ª—é—á
        key = ''.join(sorted(s))
        anagram_groups[key].append(s)
    
    return list(anagram_groups.values())

# ==================== –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ù–û–ï –†–ï–®–ï–ù–ò–ï ====================
def group_anagrams_count(strs):
    """
    –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∞–Ω–∞–≥—Ä–∞–º–º —á–µ—Ä–µ–∑ –ø–æ–¥—Å—á–µ—Ç —Å–∏–º–≤–æ–ª–æ–≤
    
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n * m)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n * m)
    """
    from collections import defaultdict
    
    anagram_groups = defaultdict(list)
    
    for s in strs:
        # –°–æ–∑–¥–∞–µ–º –∫–ª—é—á –∏–∑ —á–∞—Å—Ç–æ—Ç —Å–∏–º–≤–æ–ª–æ–≤
        char_count = [0] * 26
        for char in s:
            char_count[ord(char) - ord('a')] += 1
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –∫–æ—Ä—Ç–µ–∂ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–∞–∫ –∫–ª—é—á
        key = tuple(char_count)
        anagram_groups[key].append(s)
    
    return list(anagram_groups.values())

# ==================== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï ====================
def test_group_anagrams():
    result = group_anagrams(["eat","tea","tan","ate","nat","bat"])
    expected = [["eat","tea","ate"], ["tan","nat"], ["bat"]]
    
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
    result_sorted = [sorted(group) for group in result]
    expected_sorted = [sorted(group) for group in expected]
    
    assert sorted(result_sorted) == sorted(expected_sorted)
    print("‚úÖ –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∞–Ω–∞–≥—Ä–∞–º–º: –≤—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã!")
```

### üî¥ –°–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏ (Hard)

#### –ó–∞–¥–∞—á–∞ 5: –ú–µ–¥–∏–∞–Ω–∞ –¥–≤—É—Ö –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤
```python
# ==================== –ó–ê–î–ê–ß–ê: –ú–ï–î–ò–ê–ù–ê –î–í–£–• –û–¢–°–û–†–¢–ò–†–û–í–ê–ù–ù–´–• –ú–ê–°–°–ò–í–û–í ====================
# –ù–∞–π—Ç–∏ –º–µ–¥–∏–∞–Ω—É –¥–≤—É—Ö –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤ –∑–∞ O(log(min(m,n)))

def find_median_sorted_arrays(nums1, nums2):
    """
    –ú–µ–¥–∏–∞–Ω–∞ –¥–≤—É—Ö –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤
    
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(log(min(m, n)))
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
    
    –ü–∞—Ç—Ç–µ—Ä–Ω: Binary Search on Answer
    """
    # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ nums1 –º–µ–Ω—å—à–µ nums2
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    
    m, n = len(nums1), len(nums2)
    left, right = 0, m
    
    while left <= right:
        # –†–∞–∑–¥–µ–ª—è–µ–º nums1 –∏ nums2
        partition_x = (left + right) // 2
        partition_y = (m + n + 1) // 2 - partition_x
        
        # –ù–∞—Ö–æ–¥–∏–º –≥—Ä–∞–Ω–∏—á–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]
        min_right_x = float('inf') if partition_x == m else nums1[partition_x]
        
        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]
        min_right_y = float('inf') if partition_y == n else nums2[partition_y]
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
        if max_left_x <= min_right_y and max_left_y <= min_right_x:
            # –ù–∞—à–ª–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ
            if (m + n) % 2 == 0:
                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2
            else:
                return max(max_left_x, max_left_y)
        elif max_left_x > min_right_y:
            # –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–∑ nums1
            right = partition_x - 1
        else:
            # –°–ª–∏—à–∫–æ–º –º–∞–ª–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–∑ nums1
            left = partition_x + 1
    
    return -1

# ==================== –ü–†–û–°–¢–û–ï –†–ï–®–ï–ù–ò–ï O(m + n) ====================
def find_median_simple(nums1, nums2):
    """
    –ü—Ä–æ—Å—Ç–æ–µ —Ä–µ—à–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —Å–ª–∏—è–Ω–∏–µ
    
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(m + n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(m + n)
    """
    merged = []
    i = j = 0
    
    # –°–ª–∏–≤–∞–µ–º –¥–≤–∞ –º–∞—Å—Å–∏–≤–∞
    while i < len(nums1) and j < len(nums2):
        if nums1[i] <= nums2[j]:
            merged.append(nums1[i])
            i += 1
        else:
            merged.append(nums2[j])
            j += 1
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —ç–ª–µ–º–µ–Ω—Ç—ã
    merged.extend(nums1[i:])
    merged.extend(nums2[j:])
    
    n = len(merged)
    if n % 2 == 0:
        return (merged[n // 2 - 1] + merged[n // 2]) / 2
    else:
        return merged[n // 2]

# ==================== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï ====================
def test_median():
    assert find_median_sorted_arrays([1, 3], [2]) == 2.0
    assert find_median_sorted_arrays([1, 2], [3, 4]) == 2.5
    assert find_median_sorted_arrays([0, 0], [0, 0]) == 0.0
    print("‚úÖ –ú–µ–¥–∏–∞–Ω–∞ –¥–≤—É—Ö –º–∞—Å—Å–∏–≤–æ–≤: –≤—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã!")
```

---

## üß© –ó–∞–¥–∞—á–∏ –ø–æ –ø–∞—Ç—Ç–µ—Ä–Ω–∞–º

### Two Pointers Pattern

#### –ó–∞–¥–∞—á–∞ 6: Container With Most Water
```python
# ==================== –ó–ê–î–ê–ß–ê: –ö–û–ù–¢–ï–ô–ù–ï–† –° –ù–ê–ò–ë–û–õ–¨–®–ò–ú –ö–û–õ–ò–ß–ï–°–¢–í–û–ú –í–û–î–´ ====================
# –ù–∞–π—Ç–∏ –¥–≤–µ –ª–∏–Ω–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤–º–µ—Å—Ç–µ —Å –æ—Å—å—é x –æ–±—Ä–∞–∑—É—é—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º –æ–±—ä–µ–º–æ–º –≤–æ–¥—ã

def max_area(height):
    """
    –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø–ª–æ—â–∞–¥—å—é
    
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1)
    
    –ü–∞—Ç—Ç–µ—Ä–Ω: Two Pointers
    """
    left, right = 0, len(height) - 1
    max_water = 0
    
    while left < right:
        # –í—ã—á–∏—Å–ª—è–µ–º —Ç–µ–∫—É—â—É—é –ø–ª–æ—â–∞–¥—å
        width = right - left
        current_height = min(height[left], height[right])
        current_area = width * current_height
        
        max_water = max(max_water, current_area)
        
        # –î–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å —Å –º–µ–Ω—å—à–µ–π –≤—ã—Å–æ—Ç–æ–π
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    
    return max_water

# ==================== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï ====================
def test_max_area():
    assert max_area([1,8,6,2,5,4,8,3,7]) == 49
    assert max_area([1,1]) == 1
    assert max_area([4,3,2,1,4]) == 16
    print("‚úÖ Container With Most Water: –≤—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã!")
```

### Sliding Window Pattern

#### –ó–∞–¥–∞—á–∞ 7: Minimum Window Substring
```python
# ==================== –ó–ê–î–ê–ß–ê: –ú–ò–ù–ò–ú–ê–õ–¨–ù–ê–Ø –ü–û–î–°–¢–†–û–ö–ê –° –û–ö–ù–û–ú ====================
# –ù–∞–π—Ç–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –ø–æ–¥—Å—Ç—Ä–æ–∫—É –≤ s, –∫–æ—Ç–æ—Ä–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ —Å–∏–º–≤–æ–ª—ã –∏–∑ t

def min_window(s, t):
    """
    –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∞-–æ–∫–Ω–æ
    
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(|s| + |t|)
    –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(|s| + |t|)
    
    –ü–∞—Ç—Ç–µ—Ä–Ω: Sliding Window
    """
    if not s or not t:
        return ""
    
    # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —á–∞—Å—Ç–æ—Ç—ã —Å–∏–º–≤–æ–ª–æ–≤ –≤ t
    dict_t = {}
    for char in t:
        dict_t[char] = dict_t.get(char, 0) + 1
    
    required = len(dict_t)  # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –≤ t
    
    # –°–∫–æ–ª—å–∑—è—â–µ–µ –æ–∫–Ω–æ
    left = right = 0
    formed = 0  # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤ —Å –Ω—É–∂–Ω–æ–π —á–∞—Å—Ç–æ—Ç–æ–π
    
    window_counts = {}
    
    # –†–µ–∑—É–ª—å—Ç–∞—Ç: (–¥–ª–∏–Ω–∞ –æ–∫–Ω–∞, –ª–µ–≤—ã–π –∏–Ω–¥–µ–∫—Å, –ø—Ä–∞–≤—ã–π –∏–Ω–¥–µ–∫—Å)
    ans = float("inf"), None, None
    
    while right < len(s):
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–∏–º–≤–æ–ª —Å–ø—Ä–∞–≤–∞ –≤ –æ–∫–Ω–æ
        character = s[right]
        window_counts[character] = window_counts.get(character, 0) + 1
        
        # –ï—Å–ª–∏ —á–∞—Å—Ç–æ—Ç–∞ —Ç–µ–∫—É—â–µ–≥–æ —Å–∏–º–≤–æ–ª–∞ –¥–æ—Å—Ç–∏–≥–ª–∞ –Ω—É–∂–Ω–æ–π
        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1
        
        # –ü—ã—Ç–∞–µ–º—Å—è —Å–∂–∞—Ç—å –æ–∫–Ω–æ, –ø–æ–∫–∞ –æ–Ω–æ –≤–∞–ª–∏–¥–Ω–æ–µ
        while left <= right and formed == required:
            character = s[left]
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–∞–º–æ–µ –º–∞–ª–µ–Ω—å–∫–æ–µ –æ–∫–Ω–æ
            if right - left + 1 < ans[0]:
                ans = (right - left + 1, left, right)
            
            # –°–∏–º–≤–æ–ª —Å–ª–µ–≤–∞ –±–æ–ª—å—à–µ –Ω–µ –≤—Ö–æ–¥–∏—Ç –≤ –æ–∫–Ω–æ
            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1
            
            left += 1
        
        right += 1
    
    return "" if ans[0] == float("inf") else s[ans[1]:ans[2] + 1]

# ==================== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï ====================
def test_min_window():
    assert min_window("ADOBECODEBANC", "ABC") == "BANC"
    assert min_window("a", "a") == "a"
    assert min_window("a", "aa") == ""
    print("‚úÖ Minimum Window Substring: –≤—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã!")
```

---

## üå≥ –ó–∞–¥–∞—á–∏ –Ω–∞ –¥–µ—Ä–µ–≤—å—è

#### –ó–∞–¥–∞—á–∞ 8: Serialize and Deserialize Binary Tree
```python
# ==================== –ó–ê–î–ê–ß–ê: –°–ï–†–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò –î–ï–°–ï–†–ò–ê–õ–ò–ó–ê–¶–ò–Ø –î–ï–†–ï–í–ê ====================
# –°–µ—Ä–∏–∞–ª–∏–∑–æ–≤–∞—Ç—å –∏ –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–æ–≤–∞—Ç—å –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Codec:
    def serialize(self, root):
        """
        –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–µ—Ä–µ–≤–∞ –≤ —Å—Ç—Ä–æ–∫—É
        
        –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
        –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
        
        –ü–∞—Ç—Ç–µ—Ä–Ω: DFS Preorder
        """
        def dfs(node):
            if not node:
                return "null"
            
            # Preorder: –∫–æ—Ä–µ–Ω—å -> –ª–µ–≤–æ–µ -> –ø—Ä–∞–≤–æ–µ
            return str(node.val) + "," + dfs(node.left) + "," + dfs(node.right)
        
        return dfs(root)
    
    def deserialize(self, data):
        """
        –î–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–æ–∫–∏ –≤ –¥–µ—Ä–µ–≤–æ
        
        –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
        –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n)
        """
        def dfs():
            val = next(values)
            if val == "null":
                return None
            
            node = TreeNode(int(val))
            node.left = dfs()
            node.right = dfs()
            return node
        
        values = iter(data.split(","))
        return dfs()

# ==================== –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ù–û–ï –†–ï–®–ï–ù–ò–ï –ß–ï–†–ï–ó BFS ====================
class CodecBFS:
    def serialize(self, root):
        """–°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ BFS (Level Order)"""
        if not root:
            return ""
        
        result = []
        queue = [root]
        
        while queue:
            node = queue.pop(0)
            if node:
                result.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
            else:
                result.append("null")
        
        return ",".join(result)
    
    def deserialize(self, data):
        """–î–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ BFS"""
        if not data:
            return None
        
        values = data.split(",")
        root = TreeNode(int(values[0]))
        queue = [root]
        i = 1
        
        while queue and i < len(values):
            node = queue.pop(0)
            
            if values[i] != "null":
                node.left = TreeNode(int(values[i]))
                queue.append(node.left)
            i += 1
            
            if i < len(values) and values[i] != "null":
                node.right = TreeNode(int(values[i]))
                queue.append(node.right)
            i += 1
        
        return root

# ==================== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï ====================
def test_serialize():
    # –°–æ–∑–¥–∞–µ–º –¥–µ—Ä–µ–≤–æ: [1, 2, 3, null, null, 4, 5]
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.right.left = TreeNode(4)
    root.right.right = TreeNode(5)
    
    codec = Codec()
    serialized = codec.serialize(root)
    deserialized = codec.deserialize(serialized)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–µ—Ä–µ–≤–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª–æ—Å—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
    assert deserialized.val == 1
    assert deserialized.left.val == 2
    assert deserialized.right.val == 3
    print("‚úÖ –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–µ—Ä–µ–≤–∞: –≤—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã!")
```

---

## üéØ –°–∏—Å—Ç–µ–º–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

### –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ç–µ—Å—Ç–∏—Ä–æ–≤—â–∏–∫
```python
# ==================== –°–ò–°–¢–ï–ú–ê –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø ====================

class TestRunner:
    def __init__(self):
        self.passed = 0
        self.failed = 0
        self.test_results = []
    
    def run_test(self, test_name, test_func):
        """–ó–∞–ø—É—Å–∫ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞"""
        try:
            test_func()
            self.passed += 1
            self.test_results.append(f"‚úÖ {test_name}: PASSED")
            print(f"‚úÖ {test_name}: PASSED")
        except Exception as e:
            self.failed += 1
            self.test_results.append(f"‚ùå {test_name}: FAILED - {str(e)}")
            print(f"‚ùå {test_name}: FAILED - {str(e)}")
    
    def run_all_tests(self):
        """–ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤"""
        print("üöÄ –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤...\n")
        
        # –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤
        tests = [
            ("Palindrome", test_palindrome),
            ("Anagram", test_anagram),
            ("Rotated Search", test_rotated_search),
            ("Group Anagrams", test_group_anagrams),
            ("Median Arrays", test_median),
            ("Max Area", test_max_area),
            ("Min Window", test_min_window),
            ("Serialize Tree", test_serialize),
        ]
        
        for test_name, test_func in tests:
            self.run_test(test_name, test_func)
        
        print(f"\nüìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã:")
        print(f"‚úÖ –ü—Ä–æ–π–¥–µ–Ω–æ: {self.passed}")
        print(f"‚ùå –ü—Ä–æ–≤–∞–ª–µ–Ω–æ: {self.failed}")
        print(f"üìà –ü—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—Ö–∞: {(self.passed / (self.passed + self.failed)) * 100:.1f}%")

# ==================== –ó–ê–ü–£–°–ö –¢–ï–°–¢–û–í ====================
if __name__ == "__main__":
    runner = TestRunner()
    runner.run_all_tests()
```

---

## üìö –ü–æ–ª–µ–∑–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è —Ä–µ—à–µ–Ω–∏—è

### Checklist –ø–µ—Ä–µ–¥ —Ä–µ—à–µ–Ω–∏–µ–º –∑–∞–¥–∞—á–∏
```python
# ==================== –ß–ï–ö–õ–ò–°–¢ –†–ï–®–ï–ù–ò–Ø –ó–ê–î–ê–ß ====================

def problem_solving_checklist():
    """
    –°–∏—Å—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–¥—Ö–æ–¥ –∫ —Ä–µ—à–µ–Ω–∏—é –∑–∞–¥–∞—á
    """
    checklist = [
        "1. üìñ –ü–æ–Ω—è—Ç—å —É—Å–ª–æ–≤–∏–µ –∑–∞–¥–∞—á–∏",
        "2. üîç –†–∞–∑–æ–±—Ä–∞—Ç—å –ø—Ä–∏–º–µ—Ä—ã –≤—Ö–æ–¥–Ω—ã—Ö/–≤—ã—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö",
        "3. ü§î –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–∞—Ç—Ç–µ—Ä–Ω —Ä–µ—à–µ–Ω–∏—è",
        "4. ‚è∞ –û—Ü–µ–Ω–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—É—é —Å–ª–æ–∂–Ω–æ—Å—Ç—å",
        "5. üíæ –û—Ü–µ–Ω–∏—Ç—å –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω—É—é —Å–ª–æ–∂–Ω–æ—Å—Ç—å",
        "6. üõ†Ô∏è –ù–∞–ø–∏—Å–∞—Ç—å –±–∞–∑–æ–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ",
        "7. üß™ –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ –ø—Ä–∏–º–µ—Ä–∞—Ö",
        "8. üîß –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –µ—Å–ª–∏ –Ω—É–∂–Ω–æ",
        "9. üéØ –£—á–µ—Å—Ç—å –∫—Ä–∞–µ–≤—ã–µ —Å–ª—É—á–∞–∏",
        "10. ‚úÖ –§–∏–Ω–∞–ª—å–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ"
    ]
    
    for item in checklist:
        print(item)
    
    return checklist

# ==================== –¢–ò–ü–ò–ß–ù–´–ï –û–®–ò–ë–ö–ò –ò –ö–ê–ö –ò–• –ò–ó–ë–ï–ñ–ê–¢–¨ ====================
def common_mistakes():
    """
    –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏ –ø—Ä–∏ —Ä–µ—à–µ–Ω–∏–∏ –∑–∞–¥–∞—á
    """
    mistakes = {
        "Off-by-one errors": "–í–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ —Ü–∏–∫–ª–æ–≤ –∏ –∏–Ω–¥–µ–∫—Å–∞–º–∏",
        "Null pointer exceptions": "–í—Å–µ–≥–¥–∞ –ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ –Ω–∞ None/null",
        "Integer overflow": "–£—á–∏—Ç—ã–≤–∞–π—Ç–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–ª—è –±–æ–ª—å—à–∏—Ö —á–∏—Å–µ–ª",
        "Wrong complexity analysis": "–ü—Ä–∞–≤–∏–ª—å–Ω–æ —Å—á–∏—Ç–∞–π—Ç–µ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Ü–∏–∫–ª—ã",
        "–ù–µ —É—á–∏—Ç—ã–≤–∞—Ç—å edge cases": "–ü—É—Å—Ç—ã–µ –º–∞—Å—Å–∏–≤—ã, –æ–¥–∏–Ω–æ—á–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã",
        "–ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –≤–æ –≤—Ä–µ–º—è –∏—Ç–µ—Ä–∞—Ü–∏–∏": "–ù–µ –∏–∑–º–µ–Ω—è–π—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≤–æ –≤—Ä–µ–º—è –æ–±—Ö–æ–¥–∞",
        "–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è": "–ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ –Ω–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö"
    }
    
    for mistake, solution in mistakes.items():
        print(f"‚ùå {mistake}: {solution}")
    
    return mistakes
```

---

## üèÜ –ü—Ä–æ–≥—Ä–µ—Å—Å-—Ç—Ä–µ–∫–µ—Ä

### –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Ä–µ—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á
```python
# ==================== –¢–†–ï–ö–ï–† –ü–†–û–ì–†–ï–°–°–ê ====================

class ProgressTracker:
    def __init__(self):
        self.solved_problems = {
            'easy': [],
            'medium': [],
            'hard': []
        }
        self.patterns_mastered = set()
        self.time_spent = 0
    
    def mark_solved(self, problem_name, difficulty, pattern, time_minutes):
        """–û—Ç–º–µ—Ç–∏—Ç—å –∑–∞–¥–∞—á—É –∫–∞–∫ —Ä–µ—à–µ–Ω–Ω—É—é"""
        self.solved_problems[difficulty].append({
            'name': problem_name,
            'pattern': pattern,
            'time': time_minutes
        })
        self.patterns_mastered.add(pattern)
        self.time_spent += time_minutes
    
    def get_stats(self):
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
        total_solved = sum(len(problems) for problems in self.solved_problems.values())
        
        stats = {
            'total_solved': total_solved,
            'easy_solved': len(self.solved_problems['easy']),
            'medium_solved': len(self.solved_problems['medium']),
            'hard_solved': len(self.solved_problems['hard']),
            'patterns_mastered': len(self.patterns_mastered),
            'total_time_hours': self.time_spent / 60
        }
        
        return stats
    
    def print_progress(self):
        """–í—ã–≤–µ—Å—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å"""
        stats = self.get_stats()
        
        print("üìä –í–∞—à –ø—Ä–æ–≥—Ä–µ—Å—Å:")
        print(f"‚úÖ –í—Å–µ–≥–æ —Ä–µ—à–µ–Ω–æ: {stats['total_solved']}")
        print(f"üü¢ Easy: {stats['easy_solved']}")
        print(f"üü° Medium: {stats['medium_solved']}")
        print(f"üî¥ Hard: {stats['hard_solved']}")
        print(f"üß© –û—Å–≤–æ–µ–Ω–æ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤: {stats['patterns_mastered']}")
        print(f"‚è∞ –í—Ä–µ–º—è –∏–∑—É—á–µ–Ω–∏—è: {stats['total_time_hours']:.1f} —á–∞—Å–æ–≤")

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
tracker = ProgressTracker()
tracker.mark_solved("Two Sum", "easy", "Hash Map", 15)
tracker.mark_solved("Longest Substring", "medium", "Sliding Window", 45)
tracker.print_progress()
```

---

*–ü—Ä–∞–∫—Ç–∏–∫–∞ ‚Äî –ª—É—á—à–∏–π —É—á–∏—Ç–µ–ª—å –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤. –†–µ—à–∞–π—Ç–µ –∑–∞–¥–∞—á–∏ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å!* üí™üß† 